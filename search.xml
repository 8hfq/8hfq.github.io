<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[English composition]]></title>
    <url>%2F2018%2F11%2F20%2Fenglish.html</url>
    <content type="text"><![CDATA[开头That chart above demonstrates clearly that some changes have taken place in terms of the … Based upon the data of the chart,one can see that the percentage of … has been on a risewhile …. has been on a declinein the year of 主体I think there are two main reasons for such a great contrast It is not difficulty for us to come up with some possible factors to account for this trend At the top of the list ,with the rapid development of our economy and society,more and more people perfetOne the one handOne the other hand 总结Taking into account what has been argued, we can com to the conclusion that this established trend is positive and therefore acceptable It is necessary that effective actions should be taken to prevent the situationIt is my view that]]></content>
      <categories>
        <category>study</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[论大型信息管理系统项目的风险管理]]></title>
    <url>%2F2018%2F11%2F07%2FProject-risk-management.html</url>
    <content type="text"><![CDATA[论大型信息管理系统项目的风险管理摘要 本文以我管理的某数据平台项目为实例，探讨了信息系统项目的风险管理在项目实施过程中的重要性。风险就是会给项目带来威胁或机会的一些不确定性的事件，2017年，我公司决定启动数据平台分析项目，我在此项目中担任项目经理一职，主要负责项目的整体规划，组织实施和管理控制工作。为了按照既定的进度，成本和质量完成项目的目标，在该项目中，我充分重视了风险管理，根据风险管理理论，结合自己的项目实践，就项目进行有效的风险管理进行了论述，重点制定了切实可行的风险管理计划，风险识别，风险分析，针对不同风险采取相应的措施，有效的对风险进行跟踪与控制等过程，有条不絮的进行风险管理。最后列出了项目实施过程中不足之处。项目系统运行正常，构建起公司数据平台。 正文 随着公司业务量和存储数据日益增加，庞大的数据量在原来的业务系统上已经变得难以分析，于是公司决定启动数据分析系统项目。该项目是一个综合性系统项目，涉及运营活动数据分析，数据报表接口，日常报表需求，用户画像智能推荐等功能。因此是一个复杂度高，涉及面广，实施周期长的复杂项目。我担任项目的项目经理，主要负责项目的整体规划，组织实施和管理控制工作。笔者认为：此项目具有规模大，周期长，复杂度高等特点，一旦出现问题，造成的损失将会难以预料，所以，重点放在对项目进行有效的风险管理方面，科学的运用相关理论知识及其指导方法，做好项目的统领工作，协调完成项目所需的所有人员，计划和工作，带领整个团队实现项目的顺利成功。 风险就是会给项目带来威胁或机会的一些不确定性事件。项目是在复杂的自然和社会环境中进行的，受众多因素的影响，对于这些内外因素，项目管理人员往往认识不足或者没有足够的力量加以控制。项目的过程和结果常常出乎人们的意料，有时不但未达到项目主体预期的目的，反而使其蒙受各种各样的损失，而有时又会给他们带来很好的机会。项目同其他的经济活动一样带有风险。要避免和减少损失，将威胁化为机会，我们必须了解和掌握项目风险的来源，性质和发生的规律。进而实行有效的管理 项目风险贯穿于项目的整个过程，成功的项目管理会大大增加项目成功的概率。笔者带领组成员主要笔者带领组成员主要是从制定切实可行风险管理计划；有效认别风险因素；分析风险对目标影响程度；针对不同风险采取相应的措施；有效地对风险进行跟踪与控制五个方面来对该项目进行有效的风险管理。 一.制定切实可行的风险管理计划 风险包括可预见风险和不可预见风险。在项目初期，笔者组织组成员，技术专家，最终用户，项目相关领域的专家，其他项目干系人等认真分析，制定了可行的风险管理计划，在计划中，具体描述可预见风险的种类及其定义发生概率和影响力，如何为该项目处理和执行风险活动，如15天开一次风险评估会议；明确了风险如何管理、用什么样的方法、某种风险分别由谁来负责，责任明确；风险评估的方法，也就是我们为什么要把某个事件当作项目的风险；若风险出现时，项目干系人能够承受的限度是多少？每项风险的预算是多少？风险如何监控？如何报告？如何跟踪、记录等；并且根据项目管理理论和公司的项目实践，估计了风险管理的时间表和费用，并把风险管理活动纳入了项目计划，把风险管理费用纳入了成本费用计划。 二、有效识别风险因素 风险识别是确定何种风险可能会对项目产生影响，并把这些风险特征描述出来。风险识别是一个在整个项目中多次反复的过程，几乎在每次的项目例会上都对风险进行回顾，已识别的风险哪些确实发生了，影响程度如何？如何应对的？还有哪些潜在可能会发生的风险？解决了前一个风险，有没有残留风险和次生风险发生。在该项目中，我们主要从立项报告、范围说明书、WBS、费用和进度估算、资源计划、假定条件和限制条件清单几方面来识别项目的风险。采取的主要方法有项目文档审阅和信息收集技术，项目文档审阅是找出项目文档中的假设条件、限制因素，理解的目标、项目范围、项目的资源计划、进度计划、成本估算等，计划的质量，以及这些计划和项目需求、假设条件的一致性都可能存在风险。通过上述方法与技术，我们找出了此项目主要的风险种类，引起这些风险的主要因素，以及可能会影响项目的方面，形成了详细的风险记录。风险种类有：对工作的分析和评估不足、流程变化的阻力、专业人才缺管或流失、没有正确理解业务问题等等。 三、认真分析风险 判断各个已识别风险的重要程度，进行优先级排序，以作为进一步风险管理活动的依据。在该项目中，笔者组织组成员、技术专家采用风险分析会议的方式来进行风险分析，以提高分析结果的准确性。在定性分析的基础上，进行风险定量分析，目标是确定能达到具体项目目标（进度、费用、质量）的可能性，量化地评估项目各风险，判定最应关注的项目风险。在这个过程中，我们采用了专家评估的方法，组织相关成员对项目进行乐观、中性和悲观估计，进行定量分析之后，更新了风险记录。 四、针对不同风险采取相应的措施 根据定性和定量分析的结果，我们对已识别的风险，制订了应对计划。使制定的措施和方法遵循风险应对计划与风险的严重程度相适应、经济有效、可操作、责任落实到人，同时，兼顾增加对项目有利的机会、减少对项目的威胁。对不同的风险，采取了不同的措施，比如： 对工作的分析和评估不足，应对措施是利用已有经验、加强学习、充分利用标准的技术和理论； 流程变革的阻力，应对措施是制定完善的变革策略、注意变革的可行性、高层领导的支持、加强宣传工作、如有大的改动需要引入变革顾问； 专业人才短缺或流失，应对措施是企业高层的重视、加强培训、紧密团结“少数人”、提高项目完成奖金、实行人才备份制； 没有正确理解业务问题，应对措施是加强对全体员工的培训、提高其信息化水平； 五、有效地对风险进行跟踪与控制 综上所述，该项目中的风险已经比较清晰，在整个项目过程中，笔者安排专人定期监督已识别风险和残留风险、识别可能出现的新风险，并根据出现的风险执行风险应对计划、评估计划执行的有效性，主要是判断：风险应对措施是否按计划实施；风险应对措施是否有效，是否需要制定新的措施；项目假定条件是否依然成立；风险的状态是否在改变；是否出现了风险征兆；是否有未识别的风险发生。在这个过程中，我们主要采用了偏差分析、项目绩效分析和监控会议的方式来进行的。 经过努力，该项目已经顺利成功地实施，目前系统运行正常，受到公司方的一致好评。该项目由于投资规模大、建设周期长等原因，充满着风险，项目成功很大程度归功于我们十分重视项目的风险管理，在整个项目建设过程中，始终遵循了变更控制程序，使该项目顺利完成了其目标。在以后的项目管理工作中，笔者要加强自身学习的同时，进一步提高对高层的培训，汇报时减少专业术语，切入主题，更好地完成项目。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>信息系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挣值管理]]></title>
    <url>%2F2018%2F11%2F06%2Ffor-value-management.html</url>
    <content type="text"><![CDATA[CV=EV-AC SV=EV-PV CPI=EV/AC SPI=EC/PV ETC=(BAC-EV)/CPI EAC=(AC+ETC) 一、 基本概念PV，EV，AC和BAC PV:计划价值（Planned Value, PV），截止到某时间点计划要完成工作量的价值，也就是计划要做多少事； EV:挣值（Earned Value, EV），截止到某时间点实际已经完成工作量的价值，也就是实际做了多少事,然后计算对应的计划价值 AC:实际成本（Actual Cost, AC），截止到某时间点实际已经发生的成本，也就是实际花了多少钱； BAC:完工预算（Budget At Completion, BAC），对完成该项目的计划预算，也就是完成整个项目计划多少预算； 图中红、绿、橘黄色线分别表示AC、PV和EV，红线AC表示截止到某个时点花了多少钱（成本），斜率表示花钱的速度；绿线PV表示截止某个时点项目计划花的钱和做的项目量；橘黄色线EV表示截止到某个时点做了多少事（多少钱的工作），斜率表示做事的速度；上图我们可以看出花钱的速度比计划的要快（红线比绿线更陡，斜率更大），而做事的速度却比计划的要慢（橘黄色线比绿线更缓，斜率更小），项目绩效很不好。 二、 绩效指标CV，SV，CPI和SPI CV:成本偏差（Cost Variance, CV），截止到某时点发生的实际成本与计划成本的偏差，CV=EV-AC SV:进度偏差（Schedule Variance, SV），截止到某时点的实际进度与计划进度的偏差，SV=EV-PV CPI:成本绩效指数（Cost Performance Index, CPI），截止到某时点衡量成本绩效的一种指标，也就是实际每花一元钱，完成做了多少钱的事（花钱的效率），CPI=EV/AC SPI:进度绩效指数（Schedule Performance Index, SPI），截止到某时点衡量进度绩效的一种指标，也就是实际完成的工作量与计划完成工作量之比，SPI=EV/PV 三、 预测指标ETC，EAC，TCPI和VAC 完工尚需估算（Estimate To Completion, ETC），在某个时点，预测完成剩余的工作还需要多少成本；这个时候算预测数据的时候就要分情况了，主要取决于我们以后的工作花钱的效率跟以前比是否会发生变化？也就是考察以后工作的CPI的值会不会发生变化。根据剩余部分工作CPI的变化情况，有几种计算方法： 如果还是以当前的成本绩效完成剩余的工作，则 ETC=(BAC-EV)/CPI，也就是剩余的工作量除以成本绩效指数； 如果以计划的成本绩效（其实就是1）完成剩余的工作，则ETC=BAC-EV，也就是剩余的工作量，实际上也是用第一种情况那个公式； 如果进度绩效指标SPI也会影响完成剩余工作的成本，意思是如果严格规定我们必须要在计划的截止时间之前完成项目，那么可能就还需要额外的成本来赶工进度，这个时候就需要同时考虑CPI和SPI对于剩余工作的影响，一般计算公式则为ETC=(BAC-EV)/(CPISPI)，也就是剩余的工作量除以成本绩效指数与进度绩效指数的乘积；其中CPI SPI又叫“关键比率”(Critical Ratio, CR); 完工估算（Estimate At Completion, EAC），在某个时点，预测完成整个项目需要的成本，当然就是实际已经花掉的成本加上前面那个完工尚需估算ETC，EAC=AC+ETC；如果剩余工作还是以当前成本绩效指数来完成，那么也可以这么计算EAC=BAC/CPI，这个公式也好理解，其实就是整个项目工作量除以成本绩效指数；完工估算EAC实际上就是预测项目完工时候的实际成本AC。 完工尚需绩效指数（To-Complete Performance Index, TCPI），在某个时点，预测如果要在计划的预算内完成项目，则未来的工作必须要达到的绩效水平。计算公式TCPI=(BAC-EV)/(BAC-AC)，也就是剩余的工作量除以剩余的钱的数量； 完工偏差（Variance At Completion, VAC），在某个时点，预测项目在完工的时候将会出现的总的项目的成本偏差。计算公式VAC=BAC-EAC，也就是项目开始时原计划的预算减去现在预测的总个项目将会花的成本。完工偏差VAC实际上就是预测项目完工时的成本偏差CV。 学习链接：https://www.zhihu.com/question/47750424/answer/]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>信息系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高数常用公式]]></title>
    <url>%2F2018%2F10%2F31%2Fmathematical_formula.html</url>
    <content type="text"><![CDATA[一、极限公式 二、重要公式 三、下列常用等价无穷小关系（x-&gt;0） 四、导数的四则运算法则 五、基本导数公式 六、高阶导数的运算法则 七、基本初等函数的n阶导数公式 八、微分公式与微分运算法则 九、微分运算法则 十、基本积分公式 十一、下列常用凑微分公式 十二、补充下面几个积分公式 十三、分部积分法公式 十四、第二换元积分法中的三角换元公式 十五、三角函数公式1.两角和公式 2.两倍角公式 3.半角公式 4.和差化积公式 5.积化查和公式 6.万能公式 7.平方关系 8.倒数关系 9.商数关系]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>961</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程(961)]]></title>
    <url>%2F2018%2F08%2F21%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[考试题型：概念问答题、实践案例题总分：50分 一、软件过程软件过程的概念软件过程是指软件整个生命周期，从需求获取，需求分析，设计，实现，测试，发布和维护一个过程模型。一个软件过程定义了软件开发中采用的方法，但软件过程还包含该过程中应用的技术——技术方法和自动化工具。过程定义一个框架，为有效交付软件工程技术，这个框架必须创建。软件过程构成了软件项目管理控制的基础，并且创建了一个环境以便于技术方法的采用、工作产品（模型、文档、报告、表格等）的产生、里程碑的创建、质量的保证、正常变更的正确管理。 经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）瀑布模型（Waterfall Model） 1970年Winston Royce提出了著名的”瀑布模型”，直到80年代早期，它一直是唯一被广泛采用的软件开发模型。 瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。 在瀑布模型中，软件开发的各项活动严格按照线性方式进行，当前活动接受上一项活动的工作结果，实施完成所需的工作内容。当前活动的工作结果需要进行验证，如果验证通过，则该结果作为下一项活动的输入，继续进行下一项活动，否则返回修改。 瀑布模型强调文档的作用，并要求每个阶段都要仔细验证。但是，这种模型的线性过程太理想化，已不再适合现代的软件开发模式，几乎被业界抛弃，其主要问题在于： （1） 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量； （2） 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险； （3） 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。 我们应该认识到，”线性”是人们最容易掌握并能熟练应用的思想方法。当人们碰到一个复杂的”非线性”问题时，总是千方百计地将其分解或转化为一系列简单的线性问题，然后逐个解决。一个软件系统的整体可能是复杂的，而单个子程序总是简单的，可以用线性的方式来实现，否则干活就太累了。线性是一种简洁，简洁就是美。当我们领会了线性的精神，就不要再呆板地套用线性模型的外表，而应该用活它。例如增量模型实质就是分段的线性模型，螺旋模型则是接连的弯曲了的线性模型，在其它模型中也能够找到线性模型的影子 增量模型（Incremental Model）与建造大厦相同，软件也是一步一步建造起来的。在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成. 增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。但是，增量模型也存在以下缺陷： （1） 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。 （2） 在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。 在使用增量模型时，第一个增量往往是实现基本需求的核心产品。核心产品交付用户使用后，经过评价形成下一个增量的开发计划，它包括对核心产品的修改和一些新功能的发布。这个过程在每个增量发布后不断重复，直到产生最终的完善产品。 演化模型增量模型与演化模型的相同点是：基本思想都是非整体开发，以渐增方式开发系统。他们的目的基本相同：使用户尽早得到部分软件这样能听取用户反馈。不同点：增量模型再需求设计阶段是整体进行的，在编码测试阶段是渐增进行的。演化模型全部系统是增量开发，增量提交。 统一过程模型统一过程模型是一种以“用例和风险驱动、以体系结构为核心、迭代及增量”为特征的软件过程框架，一般由UML方法和工具支持。用例是捕获需求的方法，因此，也可以说UP是需求驱动的。UP的另一个驱动就是风险，因为如果你不主动预测和防范风险，风险就会主动攻击你。UP需要对软件开发中的风险进行分析、预测并关注软件的构造。在基于组件的开发总，体系结构描述了系统的整体框架：如何把系统划分成组件以及这些组件如何进行交互和部署在硬件上。UP方法实际上就是开发和演进一个健壮的系统体系结构。此外，UP也是迭代和增量的。在UP的迭代构建中，每个迭代包括五个核心工作流：需求R-捕捉系统应该做什么。分析A-精华和结构化需求。设计D-基于系统结构来实现需求。实现I-构造软件系统。测试T-验证实现是否达到预期效果。 尽管每次迭代都可以包含这5个核心工作流，但是特定工作流的重点依赖于项目生命周期中的迭代发生的位置。迭代的一些可能工作流图解如图2-8所示。把项目划分成一系列迭代，允许对项目进行灵活计划。最简单的方法是按照时间顺序的迭代序列，一个接一个。然而，常常可能并行安排迭代。这意味着需要理解每次迭代的制品之间的依赖，需要有方法指导基于框架和模型的并行迭代。并行迭代的好处是缩短面市时间，可以更好地利用团队，但是必须仔细计划。 过程评估与CMM/CMMI的基本概念过程评估 软件过程评估所关注的是软件组织自身内部软件过程的改进问题，目的在于发现缺陷，提出改进的方向。 CMM的概念CMM(Capability Maturity Model)是能力成熟度模型的缩写,CMM是国际公认的对软件公司进行成熟度等级认证的重要标准。CMM共分五级。在每一级中，定义了达到该级过程管理水平所应解决的关键问题和关键过程。每一较低级别是达到较高级别的基础。其中五级是最高级，即优化级，达到该级的软件公司过程可自发地不断改进，防止同类问题二次出现；四级称为已管理级，达到该级的软件公司已实现过程的定量化；三级为已定义级，即过程实现标准化；二级为可重复级，达到该级的软件公司过程已制度化，有纪律，可重复；一级为初始级，过程无序，进度、预算、功能和质量等方面不可预测。 CMMI的概念（Capability Maturity Model Integration，能力成熟度模型集成）将各种能力成熟度模型，即：Software CMM、Systems Eng-CMM、People CMM和Acquisition CMM，整合到同一架构中去，由此建立起包括软件工程、系统工程和软件采购等在内的诸模型的集成，以解决除软件开发以外的软件系统工程和软件采购工作中的迫切需求。CMMI的基本思想1、解决软件项目过程改进难度增大问题2、实现软件工程的并行与多学科组合3、实现过程改进的最佳效益 敏捷宣言与敏捷过程的特点敏捷宣言也叫做敏捷软件开发宣言，正式宣布了对四种核心价值和十二条原则，可以指导迭代的以人为中心的软件开发方法。敏捷宣言强调的敏捷软件开发的四个核心价值是：个体和互动高于流程和工具工作的软件高于详尽的文档客户合作高于合同谈判响应变化高于遵循计划 敏捷过程的特点与传统开发方法相比，在敏捷开发的整个过程中，有以下几个主要的特点：（1）敏捷开发的过程有着更强的适应性而不是预设性，从敏捷宣言的第四条响应变化高于预设计划便可以看出来。因为软件开发过程的本身的不可预见性，很多用户在项目开始时不可能对于这个项目有着一个完整而明确的预期。很多对软件的预期都在后期的修改和完善过程中产生。因此高适应性显然更加符合软件工程开发的实际。而敏捷开发实现其适应性的方式主要在于，第一，缩短把项目提交给用户的周期；第二，增加用户，业务人员，开发人员这三者之间的交流；第三，通过减少重构的成本以增加软件的适应性。（2）敏捷开发的过程中，更加的注重人的因素。在传统软件工程中，个人的因素很少的被考虑到分工中，每个个体都是只是整个代码开发机器的一个小小的螺丝钉，个人的意志和创造力很大程度上的被抹去为了更好的为集体服务。而在敏捷开发过程中，每个个人的潜力被充分的考虑，应用什么技术很大程度上直接由在第一线开发的技术人员决定；每个人的特点和创造力都可以充分地发挥，这样开发出来的软件更加的具有生命力，因为他融入了开发者的心血和创意，开发者不再是进行机械的乏味的堆砌，而是创造属于自己的艺术品，这样的条件下产生的代码必然在质量上更占优势。（3）在敏捷开发的过程中，整个项目是测试驱动的而不是文档驱动的。不仅每个模块有着自己的相应的测试单元，开发人员在开发自己的模块的过程中必须保证自己所开发的模块可以通过这一单元的测试，并且集成测试贯穿了整个开发过程的始终。集成测试每天会进行十几次甚至几十次，而不是像传统方法一样只有当各个模块的编码都结束了之后再进行联合调试。这样，在软件开发的进程中每一点改动所引起的问题都容嘉容易暴露出来，使得更加容易在错误刚刚产生的时候发现问题从而解决问题。这样就避免了在最后整个系统完成时错误隐藏的太深给调试造成极大的困难。 二、软件需求软件需求的概念软件需求是 用户解决问题或达到目标所需条件或权能(Capability)。 系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能。 一种反映上面(1)或(2)所述条件或权能的文档说明。它包括功能性需求及非功能性需求，非功能性需求对设计和实现提出了限制，比如性能要求，质量标准，或者设计限制。 软件需求包括三个不同的层次—业务需求、用户需求和功能需求—也包括非功能需求。 业务需求( business requirement)反映了组织机构或客户对系统、产品高层次的目标要求，它们在项目视图与范围文档中予以说明。 用户需求(user requirement)文档描述了用户使用产品必须要完成的任务，这在使用实例(use case)文档或方案脚本(scenario)说明中予以说明。 功能需求(functional requirement)定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足了业务需求。所谓特性(feature)是指逻辑上相关的功能需求的集合，给用户提供处理能力并满足业务需求。软件需求各组成部分之间的关系如图所示。 非功能需求作为补充，软件需求规格说明还应包括非功能需求，它描述了系统展现给用户的行为和执行的操作等。它包括产品必须遵从的标准、规范和合约；外部界面的具体细节；性能要求；设计或实现的约束条件及质量属性。所谓约束是指对开发人员在软件产品设计和构造上的限制。质量属性是通过多种角度对产品的特点进行描述，从而反映产品功能。多角度描述产品对用户和开发人员都极为重要。 值得注意的一点是，需求并未包括设计细节、实现细节、项目计划信息或测试信息。需求与这些没有关系，它关注的是充分说明你究竟想开发什么。 需求工程的基本过程需求工程的活动划分为以下5个独立的阶段： 需求获取：通过与用户的交流，对现有系统的观察及对任务进行分析，从而开发、捕获和修订用户的需求； 需求建模：为最终用户所看到的系统建立一个概念模型，作为对需求的抽象描述，并尽可能多的捕获现实世界的语义； 形成需求规格：生成需求模型构件的精确的形式化的描述，作为用户和开发者之间的一个协约； 需求验证：以需求规格说明为输入，通过符号执行、模拟或快速原型等途径，分析需求规格的正确性和可行性，包含有效性检查，一致性检查，可行性检查和确认可验证性； 需求管理：支持系统的需求演进，如需求变化和可跟踪性问题。 需求获取阶段需求获取首先需要的是技术的支持，其次，在需求获取工作中主要涉及了 3 个至关重要的因素：应搜集什么信息；从什么来源中搜集信息；用什么机制或技术搜集信息。再次，需求获取的开始，代表着软件项目正式开始实施，正所谓万事开头难。综合上述 3 个点使得需求获取成为软件开发中最困难、最关键、最易出错也是最需要交流的方面。在工作开展中，主要是就业务流程、组织架构、软硬件环境和现有系统等相关内容进行沟通，挖掘系统最终用户的真正需求，把握需求的方向。在需求获取调研会中首先对需求获取方法作了验证。现行的需求获 取方法一般有基于调查的需求获取方法、基于用例的需求获取方法、原型法等几种方法。各种需求获取方法各有利弊。[7] 需求分析阶段需求分析与需求获取是密切相关的，需求获取是需求分析的基础，需求分析是需求获取的直接表现，两者相互促进，相互制约。需求分析与需求获取的不同主要在于需求分析是在已经了解承建方的实际的客观的较全面的业务及相关信息的基础上，结合软、硬件实现方案，并做出初步的系统原型给承建方做演示。承建方则通过原型演示来体验业务流程的合理化、准确性、易用性。同时，用户还要通过原型演示及时地发现并提出其中存在的问题和改进意见和方法。 需求文档编写阶段需求开发的最终成果是，在对所要开发的产品达成共识后，所编写的具体的文档。需求文档是在需求获取和需求分析两个阶段任务结束时生成的，所以文档要包含所有需求。在此阶段先要从软件工程和文档管理的角度出发依据相关的标准审核需求文档内容，确定需求文档内容是否完整。对需求文档中存留问题进行修改的工作。 需求确认阶段需求确认主要是针对《需求规格说明书》的评审，保证需求符合优秀需求成熟的特征，并且符合好的需求规格说明的特征。在需求确认阶段需要保证以下几点： （1）软件需求规格说明正确描述了预期的满足各方涉众需求的系统能力和特征。 （2）从系统需求、业务规则或其他来源中正确的推导出软件需求。 （3）需求是完整的、高质量的。 （4）需求的表示在所有地方都是一致的。 （5）需求为继续进行产品设计和构造提供充分的基础。 需求跟踪阶段与需求复用阶段需求跟踪是指通过比较需求文档与后续工作成果之间的对应关系，确保产品依据需求文档进行开发，建立与维护“需求——设计——编程——测试”之间的一致性，确保所有工作成果符合用户需求。需求跟踪是一项需要进行大量手工劳动的任务，在系统开发和维护的过程中一定要随时对跟踪联系链信息进行更新。需求跟踪能力的好坏会直接影响产品质量，降低维护成本，容易实现复用，同时，需求跟踪还需要建设方的大力支持。 需求复用阶段在软件项目实施过程中，许多不同项目间存在着许多相似的需求，尤其是类型相同的项目在不同的用户群众的实施中，需求的相似性就更加明显、更加普遍了。有了需求复用，建设方就能快速的形成一个需求的原型，这样，后期的需求工作只需要在此原型的基础上进行修改、扩充和完善即可，大大提高了需求分析的工作进度。所以，对于需求的复用就需要加以重视。对于需求复用，首要责任就是要提取可复用的需求，对需求复用的理解和扩充。其次就是要保证需求复用不存在冲突。 需求变更控制阶段需求变更在软件项目开发中是不可避免的。无休止的需求变更只会造成各种资源无休止的浪费，但是其中也不乏有许多是必要的、合理的需求变更。对于需求变更，首先是要尽量及早的发现，以避免更大的损失。其次，是要采取相应的、合理的变更管理制度和流程，这样同样可以降低需求变更带来的风险。 版本控制阶段版本控制是管理需求规格说明和其他项目文档必不可少的一个方面，也是需求变更文档化管理的最有效办法。可以详细记录发生需求变更的需求文档版本的版本，发生变更的原因，变更发生的控制记录，并对变更后的需求文档进行唯一版本号的标识。使得每个成员都能及时访问最新版本的需求文档。实施版本控制的基础是需求基线，所谓需求基线就是项目组成员一经承诺将在某一特定产品版本中实现的功能性和非功能性需求的集合。需求基线的确定可以保证项目的涉众各方可以对发布的产品中希望具有的功能和属性有一个一致的理解。 分层数据流模型用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）用例图每一个用例表示一个具体的任务，涉及与系统的外部交互，在其最简单的形式中，用例用一个椭圆表示，参与者用一个小人儿表示。 时序图时序图表示在特定用例中的交互发生的顺序涉及的对象和参与者列在图表顶端，向下垂直画一条虚线。对象之间的交互用带注释的箭头表示。虚线上的矩阵表示相关对象的生命线（比如对象实例运行所需要的时间），从上往下为交互的顺序。箭头上的注释表示对对象的调用，他们的参数，以及返回值。 数据模型建模及其UML表达（类图）类图 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 类之间的关系泛化关系(generalization)eg：自行车是车、猫是动物泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； 实现关系(realize)实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 行为模型建模及其UML表达（状态图）。数据流图（DFD）数据流图(DFD)是结构化分析方法中使用的工具,它以图形的方式描绘数据在系统中流动和处理的过程，由于它只反映系统必须完成的逻辑功能，所以它是一种功能模型。在结构化开发方法中，数据流图是需求分析阶段产生的结果。 数据流图表示法数据源点和数据汇点：指系统以外又与系统有联系的人或事物。用来表达该系统数据的外部来源和去向。数据流：指处理功能的输入或输出，箭头表示数据流向。加工或处理：指对数据进行处理加工，使数据变换。数据存储：表示某种独居保存后的逻辑统称，一般为表结构。 数据流程图实例 顶层数据流图把整个系统视为一个大的加工，然后根据数据系统从哪些外部实体接收数据流，以及系统发送数据流到那些外部实体，就可以画出输入输出图。这张图称为顶层图。 把顶层图的加工分解成若干个加工，并用数据流将这些加工连接起来，使得顶层图的输入数据经过若干加工处理后，变成顶层图的输出数据流。这张图称为0层图。从一个加工画出一张数据流图的过程就是对加工的分解。 三、软件设计与构造软件体系结构及体系结构风格的概念能够用来具体描述软件系统控制结构和整体组织的一种体系结构，能够表示系统的框架结构，用于从较高的层次上来描述各部分之间的关系和接口。软件体系结构是对系统的一种高层次的抽象描述。主要是反映拓扑属性，有意忽略细节；软件体系结构是由构件和构件之间的联系组成，构件又有它自身的体系结构；构件的描述有3个方面：计算功能、结构特性及其他特性。 设计模式的概念设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）模块化设计和建造就是在对产品进行功能分析的基础上，将产品分解成若干个功 能模块，预制好的模块再进行组装，形成最终产品。这里，模块（module）是指提供特定功 能的相对独立的单元。模块一般具有如下特征：标准化：模块是具有标准尺寸和标准接口的预制功能单元，这是组装、互换等特征 的基础。可组装：多个模块可以方便、灵活地组合、配置，以构造不同大小、不同形状、不 同功能的系统。可替换：通过用一个模块去更换另一个模块，可以改变系统的局部功能而不影响系 统的其他部分。可维护：可以对模块进行局部修改或设置，以满足用户的需求。另外可以在现有系 统中增加新模块，以扩展系统功能。 抽象 以概括性的术语描述解决方案 过程抽象和数据抽象 分离 关注点分离是一个设计概念，它表明任何复杂问题如果被分解成可以独立解决或者优化的若干块，该复杂问题可以更容易得到处理 分而治之 模块化 是关注点分离最常见的表现 软件被划分为独立命名可处理的构建，有时被称为模块，把这些构建集成到一起可以满足问题的需求。模块化设计使开发工作更易于规划；可以定义和交付软件增量；更容易实施变更；更有效的开展测试和调试；可以进行长期维护而没有严重的副作用。 封装 信息隐藏 每个模块对其他所有模块都隐蔽自己的升级决策，话句话说，模块应该被特别说明并设计，使信息都包含在模块内，其他模块无法对这些信息进行访问 功能独立 独立性可以通过两条定性的标准进行评估：内聚性和耦合性。内聚性显示了某个模块相关功能的强度，耦合性相识了模块间的相互依耐性。 软件重构的概念重构是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为。 面向对象设计原则（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则） 设计类 依赖倒置 测试设计 设计模型 数据设计元素 体系结构设计元素 接口设计元素 构件级设计元素 部署级设计元素 单一职责原则（Single Responsibility Principle，简称SRP ）核心思想：应该有且仅有一个原因引起类的变更问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。 里氏替换原则（Liskov Substitution Principle,简称LSP）核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。 依赖倒置原则（Dependence Inversion Principle,简称DIP）核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。 接口隔离原则（Interface Segregation Principle,简称ISP）核心思想：类间的依赖关系应该建立在最小的接口上通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。需注意：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 迪米特法则（Law of Demeter,简称LoD）核心思想：类间解耦。通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 开放封闭原则（Open Close Principle,简称OCP）核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。 一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 内聚与耦合的概念、常见的内聚和耦合类型。 四、软件测试软件测试及测试用例的概念测试策略单元测试单元测试侧重于软件设计的最小单元（软件构建或模块）的验证工作。利用构件级设计描述作为指南，测试重要的控制路径以发现模块内的错误。测试的相对复杂度和这类测试发现的错误受到单元测试约束范围的限制。单元测试侧重于构件的内部处理逻辑和数据结构，这种类型的测试可以对多个构件并行执行。 集成测试集成测试时构建软件体系结构的系统化技术，同时也是进行一些旨在发现与接口相关的错误的测试。其目标是利用已通过单元测试的构建建立设计中描述的程序结构增量集成程序以小增量的方式逐步进行构建和测试，这样错误易于分离和纠正，更易于对接口进行彻底测试，而且可以运用系统化的测试方法。 自顶向下集成 自底向上集成 回归测试 每当加入一个新模块作为集成测试的一部分的时候，回归测试重新执行已经测试过的某些子集，以确保变更没有传播不期望的副作用。回归测试有利于保证变更不引入无意识行为或者额外的错误。 冒烟测试 确认测试确认测试始于集成测试的结束，在那时已测完单个构件，软件已经组装成完整的软件包，接口错误已经被发现和改正。测试集中于用户可见的动作和用户可识别的系统输出。通过一系列表明软件功能与软件需求相符合的测试而获得的。即对于那些最终用户显而易见的错误。 系统测试 恢复测试 通过各种方式强制的让系统发生故障，并验证其能适当恢复 安全测试 验证建立在系统内的保护机制是否能够实际保护系统不受非法入侵 压力测试 要求以一种非正常的数量，频率或容量的方式执行系统 性能测试 用来测试软件在集成环境中的运行性能 部署测试 在软件将要运行的每一种环境中运行软件 调试调试出现在成功的测试之后，也就是说，当测试用例发现错误的时候，调试就是使错误消除的过程。调试并不是测试，但是调试总是发生在测试之后，执行测试用例，对测试结果进行评估，期望的表现和实习表现不一致的时候，调试的过程就开始了。调试试图找到隐藏在症状背后的原因，从而使错误得到修正。 调试方法： 蛮干法 最常用但是低效 回溯法 原因排除法 自动调试 测试覆盖度测试覆盖度评估是衡量阶段性软件测试执行状态的重要手段之一，来确定测试是否达到事先设定的测试任务完成的标准。测试覆盖率则是测试覆盖度评估中一种量化的表示方法，一般通过被测试的软件产品需求、功能点、测试用例数或程序代码行等来进行计算。 软件测试覆盖率常用的计算公式： 功能覆盖率= 至少被执行一次的测试功能点数/ 测试功能点总数 （功能点） 需求覆盖率= 被验证到的需求数量 /总的需求数量 （需求） 覆盖率= 至少被执行一次的测试用例数/ 应执行的测试用例总数 （测试用例） 语句覆盖率= 至少被执行一次的语句数量/ 有效的程序代码行数 判定覆盖率= 判定结果被评价的次数 / 判定结果总数 条件覆盖率= 条件操作数值至少被评价一次的数量 / 条件操作数值的总数 判定条件覆盖率= 条件操作数值或判定结果至少被评价一次的数量/(条件操作数值总数+判定结果总数) 上下文判定覆盖率= 上下文内已执行的判定分支数和/(上下文数上下文内的判定分支总数) 基于状态的上下文入口覆盖率= 累加每个状态内执行到的方法数/(状态数*类内方法总数) 分支条件组合覆盖率= 被评测到的分支条件组合数/分支条件组合数 路径覆盖率= 至少被执行一次的路径数/程序总路径数 白盒测试白盒测试有时候也被称之为玻璃盒测试或者结构化测试。它利用作为构建级设计的一部分所描述的控制结构来生成测试用例。利用白盒测试方法导出的测试用例可以： 保证一个模块中的所有路径至少被执行一次 对所有的逻辑判定均需测试取真和取假两个方面 在上下便捷及可操作的范围内执行所有的循环 检验内部数据结构以确保其有效性 基本路径测试基本路径测试允许测试用例设计者设计出过程设计的逻辑复杂性测量，并以这种测量为直到来定义执行路径的基本集。执行该基本集导出的测试用例保证程序中的每一条语句至少执行一次。 流图表示独立程序路径独立路径是任何贯穿程序、至少引入一组新处理语句或一个新条件的路径。如何知道要找出多少路径环复杂性的计算环复杂性是一种软件度量，它为程序的逻辑复杂度提供了一个量化的测度。用在基本路径测试方法的环境下时，环复杂性的值定义了程序基本集合中的独立路径数，并提供了保证所有语句至少执行一次所需测量数量的上限。可以通过一下三种方法之一来计算环复杂度 流图中域的数量与环复杂性相对应 对于流图G，环复杂度V(G)也可以定义如下$V(G) =E-N+2$E为流图的边数，N为流图的结点数。 对于流图G，环复杂度V(G)也可以定义如下$V(G) =P+1$P为包含在流图G中的判定结点数。生成测试用路 以设计或源代码为基础，画出相应的流图 确定所得流图的环复杂性 确定线性独立路径的基本集合 准备测试用例，强制执行基本集合中的每条路径 黑盒测试黑河测试也称为行为测试或功能测试，侧重于软件的功能需求。黑盒测试试图发现以下类型的错误： 不正确或遗漏的功能 接口错误 数据结构或者外部数据库访问错误 行为或性能错误 初始化和终止错误黑盒测试应用在测试的后期阶段，侧重于信息域等价类划分 等价类划分是一种黑盒测试方法，它将程序的输入划分为若干个数据类，从中生成测试用例。理想的测试用例可以单独发现一类错误，否则在观察到一般的错误之前需要运行许多测试用例。等价类划分的测试用例设计师基于对输入条件的等价类进行评估。 边界值分析大量的错误发生在输入域的边界，而不是发生在输入域的中间，边界值分析选择一组测试用例检查边界值]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>961</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统基础(961)]]></title>
    <url>%2F2018%2F08%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[第二部分 计算机系统基础考试题型：问答、分析、编程总分：40分 一 、处理器体系结构CPU中的时序电路ISA一个处理器支持的指令和指令的字节级编码称为他的指令集体系结构ISAISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层CPU循序的指令集编码，并且顺序的执行指令，也就是先取出一条指令，等他执行完毕再开始下一条，然而，现代处理器的实际工作方式可能跟ISA隐含的计算模型大相径庭。通过同时处理多条指令的不同部分，处理器可以获得较高的性能。但其必须对外表现出符合ISA模型的执行结果。在计算机科学中，用巧妙的方法在提高性能的同时，又保持一个更简单、更抽象模型的功能，这种思想是众所周知的（抽象）。 CPU硬件简介 计算对位进行操作的函数的组合逻辑 存储位的存储器元素（寄存器） 控制存储器元素更新的时钟信号 逻辑门是数字电路的基本计算元素，他们产生的输出等于他们输入位值得某个布尔函数，将很多逻辑门组成一个网，就能构建计算块，称为组合电路 算术/逻辑单元 是一种很重要的组合电路，这个电路有三个输入：两个数据输入及一个控制输入，根据控制输入的位置，电路会对数据输入执行不同的算术或逻辑操作。 存储器和时钟 组合电路从本质上讲，不存储任何信息。它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制，时钟是一个周期性信号，决定了什么时候要把新值加载到设备中。大多数时候，寄存器都保持在稳定状态(用x表示)，产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入(用y表示)，但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输入信号才加载到寄存器中，成为下一个状态y，直至下一个时钟的上升沿。寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。 寄存器文件 (通用寄存器组成的逻辑块) 有两个读端口，还有一个写端口。电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明选择哪个程序寄存器。虽然寄存器文件不是组合电路，因为它有内部存储。不过，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。 指令编码 指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。每条指令需要1——6个字节不等，这取决于需要哪些字段。每条指令的第一个字节表明指令的类型：高4位是代码部分(例：6为整数类操作指令)，低4位是功能部分(例：1为整数类中的减法指令) 61合起来即为sub指令。 单周期处理器的设计首先要理解什么叫单周期CPU（与后面多周期CPU对比）单周期CPU指的是一条指令的执行在一个时钟周期内完成，然后开始下一条指令的执行，即一条指令用一个时钟周期完成。 单周期CPU，是在一个时钟周期内完成这五个阶段的处理。处理一条指令的序列：取指(IF)根据程序计数器PC中的指令地址，从存储器中取出一条指令，同时，PC根据指令字长度自动递增产生下一条指令所需要的指令地址，但遇到“地址转移”指令时，则控制器把“转移地址”送入PC，当然得到的“地址”需要做些变换才送入PC。译码(ID)对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相应的操作控制信号，用于驱动执行状态中的各种操作。执行(EXE)根据指令译码得到的操作控制信号，具体地执行指令动作，然后转移到结果写回状态。访存(MEM)所有需要访问存储器的操作都将在这个步骤中执行，该步骤给出存储器的数据地址，把数据写入到存储器中数据地址所指定的存储单元或者从存储器中得到数据地址单元中的数据。写回(WB)指令执行的结果或者访问存储器中得到的数据写回相应的目的寄存器中。 更新PC(PC update) 程序计数器根据指令代码和分支标志，从前几步得出的信号值中，选出下一个PC的值。 流水线处理器的基本原理我们通过将执行每条指令所需的步骤组织成一个统一的流程，就可以用很少量的各种硬件单元以及一个时钟来控制计算的顺序，从而实现整个处理器。不过这样一来，控制逻辑就必须要在这些单元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。（CPU内有三种总线：控制总线、地址总线、数据总线） Data Hazard的处理流水线设计中的其他问题二、优化程序性能内容：优化程序性能、优化编译器的能力和局限性以及表示程序性能、特定体系结构或应用特性的性能优化、限制因素、确认和消除性能瓶颈 三、存储器结构及虚拟存储器内容：局部性、存储器层级结构、计算机高速缓存器原理、高速缓存对性能的影响、地址空间、虚拟存储器、虚拟内存的管理、翻译和映射、TLB、动态存储器分配和垃圾收集 四、链接、进程及并发编程内容：静态链接、目标文件、符号和符号表、重定位和加载、动态链接库、异常和进程、进程控制和信号、进程间的通信、进程间信号量的控制、信号量，各种并发编程模式，共享变量和线程同步，其他并行问题 五、系统级I/O和网络编程内容：I/O相关概念、文件及文件操作、共享文件、网络编程、客户端-服务器模型，套接字接口、HTTP请求，Web服务器]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>961</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(961)]]></title>
    <url>%2F2018%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[考试题型：问答、分析、编程总分：60分 由于C代码写的着实不熟练，本文代码逐步由java代替声明：本文仅供个人复习使用 一、栈（Stack）、队列（Queue）和向量（Vector）线性表的基本概念和实现线性表的存储结构有顺序存储和链式存储结构两种。前者被称为顺序表，后者被称为链表。 顺序表顺序表就是把线性表中所有的元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储空间，这样线性表的第一个元素的存储位置就是指定的存储位置，第i+1个的存储位置紧跟着第i个元素的位置 链表在链表存储中，每个结点不仅包含所存元素的信息，还包含元素之间的逻辑关系的信息，如单链表中前驱结点包含后继结点的地址信息，这样就可以通过前驱结点的位置找到后继结点的位置 两种存储结构的比较顺序表 随机访问特性，位置是确定的 要求占用连续的存储空间，存储分配只能预先进行，即静态分配 插入操作要移动多个元素 链表 不支持随机访问 结点中的存储精简利用率稍低一些 支持存储空间的动态分配 插入操作无需移动元素 多种链表形式单链表带头结点的单链表头指针head 指向头结点，头指针值域不包含任何信息，从头结点的后继结点开始存储信息，头指针始终不为null，当head-&gt;next 等于NULL的时候，链表为空 不带头结点的单链表头指针head直接指向开始结点，当head为NULL的时候，链表为空 注意：不论是带有节点的链表还是不带头结点的链表。头指针都指向链表中的第一个结点，；而头结点是带头结点的链表中的第一个结点，只作为链表存在的标志 双链表双链表就是在单链表的结点上增添一个指针域，指向当前结点的前驱同样 双链表也分为带头结点的双链表和不带头结点的双链表 循环单链表将单链表的最后一个指针域指向链表中的第一个结点即可 循环双链表循环双链表的构造源自双链表，即将终端结点的next指针指向链表中第一个结点，将链表中第一个结点的prior指针指向终端结点。 带头结点的循环双链表当head-&gt;next和heaad-&gt;prior两个指针都等于head时链表为空。不带头结点的循环双链表当head等于null的时候为空。 静态链表静态链表借助一位数组来表示，结构体数组中的每一个结点含有两个分量：一个是数据结构元素分量data，另一个是指针分量，指示了当前结点的直接后继结点在数组中的位置 链表的操作单链表的操作单链表删除结点删除”节点30”删除之前：”节点20” 的后继节点为”节点30”，而”节点30” 的后继节点为”节点40”。删除之后：”节点20” 的后继节点为”节点40”。 单链表增加结点在”节点10”与”节点20”之间添加”节点15”添加之前：”节点10” 的后继节点为”节点20”。添加之后：”节点10” 的后继节点为”节点15”，而”节点15” 的后继节点为”节点20”。 单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。 双链表操作双链表删除节点删除”节点30”删除之前：”节点20”的后继节点为”节点30”，”节点30” 的前继节点为”节点20”。”节点30”的后继节点为”节点40”，”节点40” 的前继节点为”节点30”。删除之后：”节点20”的后继节点为”节点40”，”节点40” 的前继节点为”节点20”。 双链表添加节点在”节点10”与”节点20”之间添加”节点15”添加之前：”节点10”的后继节点为”节点20”，”节点20” 的前继节点为”节点10”。添加之后：”节点10”的后继节点为”节点15”，”节点15” 的前继节点为”节点10”。”节点15”的后继节点为”节点20”，”节点20” 的前继节点为”节点15”。 栈栈的基本概念 栈是一种只能在一端进行插入或删除操作的线性表。其中允许进行插入或者删除操作的一端称为栈顶（TOP）。栈顶由一个称谓栈顶指针的位置指示器（其实就是一个变量），对于顺序栈，就是记录栈顶元素所在数组位置标号的一个整形变量，对于链式栈就是记录栈顶元素所在的结点地址的指针。另一端被称为栈底，栈底是固定不变的。 栈的特点，先进后出（FILO） 栈的存储结构，可用顺序表和链表来存储栈，分为顺序栈和链式栈。 即栈的本质上是线性表 当n各元素以某种顺序进栈，并且可以在任意时刻出栈，所获得的元素排列的数目N满足函数 $ N=1/(n+1)C^n_{2n} $ 栈通常包括的三种操作：push、peek、pop。push – 向栈中添加元素。peek – 返回栈顶元素。pop – 返回并删除栈顶元素的操作。 顺序栈（栈的数组实现）顺序栈的特殊状态和操作 栈空状态st.top==-1 有的书上规定st.top ==0为栈空条件 栈满状态st.top==maxSize-1 maxSize为栈中最大元素的个数，则maxSize-1 为栈满时栈顶元素在树组中的位置 非法状态（上溢和下溢）栈满继续进入栈就会出现上溢状态，栈空继续出栈就会出现下溢状态 进栈操作 ++(st.top);st.data[st.top]=x; 出栈操作 x=st.data[st.top];–(st.top); 链栈链栈的特殊状态和操作 栈空状态 lst-&gt;next==NULL 栈满状态 不存在栈满的情况 元素进栈操作 p-&gt;next=lst-&gt;next; lst-&gt;next=p p=lst-&gt;next;x=p-&gt;data;lst-&gt;next=p-&gt;next;free(p) 队列队列的基本概念 队列也是一种受限制的线性表，其显示为仅允许在表的一端进行插入，在表的另一端进行删除，可进行插入的一端是队尾，颗进行删除的一头是队头。 队列的特点，先进先出（FIFO） 可用顺序表和链表来存储队列，队列按存储结构颗分为顺序队和链队两种。 顺序队循环队列 为了深刻体会到循环队列这个结构优于非循环队列的地方，我们将首先介绍数组实现的非循环队列结构。队列这种数据结构，无论你是用链表实现，还是用数组实现，它都是要有两个指针分别指向队头和队尾。在我们数组的实现方式中，用两个int型变量用于记录队头和队尾的索引。 一个队列的初始状态，head和tail都指向初始位置（索引为0处）。head永远指向该队列的队头元素，tail则指向该队列最后一个元素的下一位置，当有入队操作时： 当有出队操作时： 当遇到出队操作时，head会移向下一元素位置。当然，对于这种方式入队和出队，队空的判断条件显然是head=tail，队满的判断条件是tail=array.length（数组最后一个位置的下一位置）。显然，这种结构最致命的缺陷就是，tail只知道向后移动，一旦到达数组边界就认为队满，但是队列可能时刻在出队，也就是前面元素都出队了，tail也不知道。例如：此时tail判断队满，我们暂时认为资源利用是可以接受的，但是如果接下来不断发生出队操作：此时tail依然通过判断，认为队满，不能入队，这时数组的利用率我们是不能接受的，这样浪费很大。所以，我们引入循环队列，tail可以通过mode数组的长度实现回归初始位置，下面我们具体来看一下。按照我们的想法，一旦tail到达数组边界，那么可以通过与数组长度取模返回初始位置，这种情况下判断队满的条件为tail=head 循环队列的特殊状态和操作 队空状态 qu.rear=qu.front 队满状态 （qu.rear+1）%maxSize == qr.front 元素x进队操作（移动队尾指针）qu.rear =(qu.rear+1) %maxSize;qu.date[qu.rear]=x; 元素x出队操作（移动队首指针）qu.front =(qu.front+1)%maxSize;x=qu.data[qu.front]; 链队链队的特殊状态和操作 队空状态 lqu-&gt;rear=NULL 或者 lqu-&gt;front=NULL 队满状态 不存在队满状态 （假设内存无限大的情况下） 元素进队操作 lqu-&gt;rear-&gt;next-&gt;p;lqu-&gt;rear=p; 元素出队操作 p=lqu-&gt;front;lqu-&gt;front=p-&gt;next;x=p-&gt;data;free(p) 向量 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 顺序序列顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。 动态数组支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。 能够感知内存分配器的（Allocator-aware）容器使用一个内存分配器对象来动态地处理它的存储需求。 vector的扩充机制：按照容器现在容量的一倍进行增长。vector容器分配的是一块连续的内存空间，每次容器的增长，并不是在原有连续的内存空间后再进行简单的叠加，而是重新申请一块更大的新内存，并把现有容器中的元素逐个复制过去，然后销毁旧的内存。这时原有指向旧内存空间的迭代器已经失效，所以当操作容器时，迭代器要及时更新。 抽象数据结构（ADT）一个抽象数据结构（Abstract Data type）可以看做一些数据对象以及附加在这些对象上的操作的集合。对于栈来说，数据对象集为存储在栈内的数据元素操作集为元素进栈，元素出栈，判断栈是否为空等操作 ADT 栈(stack)123456789101112Data同线性表。元素具有相同的类型，相邻元素具有前驱和后堆关系。OperationInitStack ( *S )：初始化操作.建立一个空栈S。DestroyStack ( *S )：若栈存在，則销毁它。ClearStack (*S)：将栈清空。StackEmpty ( S ):若栈为空，返回true,否則返回 false。GetTop (S,*e)：若栈存在且非空，用e返回S的栈顶元素。Push (*S,e)：若栈S存在，插入新元素e到栈S中并成为栈頂元素。Pop (*S,*e)：删除栈S中栈顶元素，并用e返回其值。StackLength (S)：返回回栈S的元素个数。endADT ADT 队列(Queue)12345678910111213Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation InitQueue(*Q)：初始化操作，建立一个空队列Q。 DestroyQueue(*Q)：若队列Q存在，則销毀它。 ClearQueue(*Q)：将队列 Q 清空。 QueueEmpty(Q)：若队列Q为空，送回true,否則退回false。 GetHead(Q, *e)：若队列Q存在且非空，用e返因队列Q的队头元素。 EnQueue(*Q,e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。 DeQueue(*Q, *e)：刪除队列Q中队头元素，并用e返回其值。 QueueLength(Q)：送回队列Q的元素个教。endADT 二、树树的基本概念和术语树是一种非线性的数据结构他是若干结点（A,B,C…等都是结点）的集合，是由唯一的根A和若干颗互不相交的子树组成的。其中每一棵子树又是一棵树，也是由唯一的根结点和若干颗互不相交的子树组成的。由此可知，树的定义是递归的。 树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的子树数目称为结点的度。度为0的结点称为叶结点或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。结点的子树的根称为该结点的孩子。相应地，该结点称为孩子的双亲。同一个双亲的孩子之间互称为兄弟（Sibling）。结点的祖先(Ancestor)是从根到该结点所经分支上的所有结点。结点的层次：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第L层，则其子树的根就在第L+1层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度或高度(Depth)。如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。森林是m(m&gt;=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。 二叉树的先序,中序,后序,层次序遍历;先序遍历操作过程如下如果二叉树为空树，则什么都不做，否则：1）访问根节点2）先序遍历左子树3）先序遍历右子树对应的算法描述如下 12345678void preorder(BTNode *p)&#123; if(p!=NULL)&#123; Visit(p); preorder(p-&gt;lchild); preorder(p-&gt;rchild); &#125;&#125; 中序遍历操作如下如果二叉树为空树，则什么都不做，否则：1）中序遍历左子树。2）访问根节点。3）中序遍历右子树。对应的算法描述如下 1234567void inorder(BTNode *p)&#123; if(p!=NULL)&#123; preorder(p-&gt;lchild); Visit(p); preorder(p-&gt;rchild); &#125;&#125; 后序遍历操作如下如果二叉树为空树，则什么都不做，否则：1）后序遍历左子树。2）后序遍历右子树。3）访问根节点。对应的算法描述如下 1234567void postorder(BTNode *p)&#123; if(p!=NULL)&#123; preorder(p-&gt;lchild); preorder(p-&gt;rchild); Visit(p); &#125;&#125; 层次遍历如图所示为二叉树的层次遍历，即按照箭头所示方向，按照1，2，3，4的层次顺序对二叉树中的各个结点访问。要进行层次遍历需要建立一个循环队列，先将二叉树头结点入队列，然后出队列，访问该结点，如果他有左子树，则将左子树的根节点入队，如果他有右子树，则将右子树的根节点入队，然后出队列，对出对结点访问，如此反复，直到队列为空为止。得到的算法如下 12345678910111213141516171819202122232425void level(BTNode *p) &#123; int front, rear; BTNode *que[maxSize]; front = rear = 0; BTNode *q; if (p != NULL) &#123; rear = (rear + 1) % maxSize; que[rear] = p; while (front != rear) &#123; front = (front + 1) maxSize; q = que[front]; Visit(q); if (q-&gt;lchild != NULL) &#123; rear = (rear + 1) % maxSize; que[rear] = q-&gt;lchild; &#125; if (q-&gt;rchild != NULL) &#123; rear = (rear + 1) % maxSize; que[rear] = q-&gt;rchild; &#125; &#125; &#125;&#125; 二叉树遍历算法的改进二叉树深度优先遍历算法的非递归实现 先序遍历非递归算法 出栈时判断是否有孩子，右孩子先入栈，左孩子后入栈，因为对左孩子的访问要先于右孩子 结点1入栈 1出栈，输出结点1，并将1的左右孩子2，4入栈，右孩子先入栈，左孩子后入栈。因为对左孩子的访问要先于右孩子，后入栈的会先出栈访问 2出栈，并将2的左右孩子3和5入栈 3出栈，3无叶子节点 5出栈 4出栈，此时栈空，进入终态 遍历顺序为1，2，3，4，5 12345678910111213141516public List&lt;Integer&gt; preorderTraversal(TreeNode root)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; treeNodeStack = new Stack&lt;&gt;(); if(root ==null) return resultList; treeNodeStack.push(root); while (!treeNodeStack.isEmpty())&#123; TreeNode tempNode = treeNodeStack.pop(); if (tempNode!=null)&#123; resultList.add(tempNode.val); treeNodeStack.push(tempNode.right); treeNodeStack.push(tempNode.left); &#125; &#125; return resultList; &#125; 中序遍历非递归算法 入栈即考虑左孩子是否存在，存在则入，出栈考虑其右孩子是否存在，存在则入。 1入栈 1的左孩子2存在 2入栈 2的左孩子3存在 3入栈 3的左孩子不存在 3出栈 3的右孩子不存在 2出栈，2的右孩子5存在，故5入栈 5的左孩子不存在 5出栈，5的右孩子不存在 1出栈，1的右孩子4存在，4 入栈 4出栈，此时栈空综上步骤得知： 开始根节点入栈 循环进行如下操作：如果栈顶的左孩子存在，则左孩子入栈，如果栈顶的左孩子不存在，则出栈并且输出栈顶结点，然后检查其右孩子是否存在，如果存在，则右孩子入栈。 当栈空时，算法结束 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; treeNodeStack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur!=null || !treeNodeStack.empty())&#123; while (cur!=null)&#123; treeNodeStack.add(cur); cur= cur.left; &#125; cur = treeNodeStack.pop(); resultList.add(cur.val); cur = cur.right; &#125; return resultList;&#125; 后序遍历非递归算法 非递归先序遍历算法中的对左右子树的遍历顺序交换就可以得到逆后序遍历序列，然后将逆后序遍历序列逆序就得到了后序遍历。因此我们需要两个栈 线索二叉树中序线索二叉树线索二叉树(引线二叉树) 的定义如下:一个二叉树通过如下的方法“穿起来”： 所有原本为空的右(孩子)指针改为指向该节点在中序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱。 线索二叉树能线性地遍历二叉树，从而比递归的 中序遍历更快。使用线索二叉树也能够方便的找到一个节点的父节点，这比显式地使用父亲节点指针或者栈效率更高。这在栈空间有限，或者无法使用存储父节点的栈时很有作用（对于通过深度优先搜索来查找父节点而言)。 考虑这样的例子：一个节点k有一个右孩子r，那么r的左指针可能是指向一个孩子节点，或是一个指回k的线索。如果r有左孩子，这个左孩子同样也应该有一个左孩子或是指回k的线索。对于所有的左孩子同理。因此沿着这些从r发出的左指针，我们最终会找到一个指回k的线索。这种特性是对称的：当q是p的左孩子时，我们可以沿着q的右孩子找到一个指回p的线索。传统的二叉树一般都是以链式存储的结构来表示。这样，二叉树中的每个节点都可以用链表中的一个链节点来存储，每个链节点就包含了若干个指针。但是，这种传统的链式存储结构只能表现出二叉树中节点之间的父子关系，而且不能利用空余的指针来直接得到某个节点的在特定的遍历顺序（先序，中序，后序）中的直接前驱和直接后继。通过分析传统的二叉树链式存储结构表示的二叉树中，存在大量的空闲指针。若能利用这些空指针域来存放指向该节点的直接前驱或是直接后继的指针，则可以进行某些更方便的运算。这些被重新利用起来的空指针就被称为线索，加上了这些线索的二叉树就是线索二叉树。 二叉树及其性质二叉树的定义1）每个结点最多只有2颗子树，即二叉树中节点的度只能为0，1，22）子树有左右顺序之分，不能颠倒。 性质1非空二叉树上叶子结点数等于双分支结点数加1性质2二叉树的第i层上最多有$2^{i-1}$个结点性质3高度或深度为k的二叉树最多有$2^k-1$个结点。换句话说，满二叉树中前k层的结点个数为$2^k-1$性质4有n个结点的完全二叉树，对各结点从上到下，从左到右依次编号（编号范围1~n）则结点之间有如下的关系若i为某结点a的编号则：如果i≠1，则a双亲结点的编号为 ⌊i/2⌋.如果2i≤n，则a左孩子的编号为2i；如果2i&gt;n，则a无左孩子。如果2i+1≤n，则a右孩子的编号为2i+1；如果2i+1&gt;n，则a无右孩子。性质5函数Catalan():给定n个结点，能够构成h(n)中不同的二叉树 $h(n)=Cn=C(2n,n)/(n+1) $注：$C(n,r)=n!/[r!(n-r)!]$性质6具有n(n&gt;0)个结点的完全二叉树的高度为$log_2n$ 普通树与二叉树的转换树转换成二叉树树转换成二叉树的过程如下1）将同一结点的各孩子结点用线串起来2）将每个结点的分支从左到右除了第一个外，其余的都剪掉，整理即可得到 二叉树转换成树二叉树转换为树是树转换为二叉树的逆过程，其步骤是：1）若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；2）删除原二叉树中所有结点与其右孩子结点的连线；3）整理（1）和（2）两步得到的树，使之结构层次分明。 森林转换成二叉树森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。 将森林转换为二叉树的步骤是：1）先把每棵树转换为二叉树；2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。 二叉树转换成森林二叉树转换为森林比较简单，其步骤如下：1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；2）把分离后的每棵二叉树转换为树；3）整理第（2）步得到的树，使之规范，这样得到森林。 森林和树的遍历根据树与二叉树的转换关系以及二叉树的遍历定义可以推知，树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知，森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同。 树的存储结构,标准形式顺序存储结构树的顺序存储结构最简单直观的是双亲存储结构，用一维数组即可实现。将所有结点存到一个数组中。每个结点都有一个数据域data和一个数值parent指示其双亲在数组中存放的位置。根结点由于没有父结点，parent用-1表示。int tree[maxSize] 链式存储结构1）孩子存储结构孩子存储结构实质上就是图的邻接表存储结构树就是一种特殊的图，把图中的多对多关系删减成一对多关系即可的得到树2）孩子兄弟存储结构树转换成二叉树的过程 完全树(complete tree)的数组形式存储树的应用二叉排序树和平衡二叉树与查找关系密切，因为放到查找一章讲解 Huffman树的定义与应用Huffman树相关的概念1）路径：是指在一棵树中，从一个节点到另一个节点之间的分支构成的通路，如从节点8到节点1的路径如下图所示：2）路径的长度：是指路径上的分支数目，在上图中，路径长度为2。3）树的路径长度：是指从根到每个结点的路径长度之和。4）带权路径长度：结点具有权值，从该结点到根之间的路径长度乘以结点的权值，就是该结点的带权路径长度。5）树的带权路径长度：是指树中所有叶子节点的带权路径之和。6 节点的权：指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值 有了如上的概念，对于Huffman树，其定义为：给定n权值作为n个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。 Huffman树的构建给定n个权值，用这n个权值来构建赫夫曼树的算法描述如下：1）将这n个权值分别看成只有根节点的n棵二叉树，将这些二叉树的集合记为F。2）从F中选出两颗根结点的权值最小的树，作为左右子树，构建一棵新的二叉树，新的二叉树的根结点的权值为左右子结点的权值之和。3）从F中删去a,b，加入新构建的树C4）重复2，3步，直到F中只剩下一棵树为止，这棵树就是赫夫曼树。 对于树中节点的结构为： 1234567struct huffman_node&#123; char c; int weight; char huffman_code[LEN]; huffman_node * left; huffman_node * right;&#125;; 对于Huffman树的构建过程为： 1234567891011121314151617181920212223242526272829303132333435363738394041int huffman_tree_create(huffman_node *&amp;root, map&lt;char, int&gt; &amp;word)&#123; char line[MAX_LINE]; vector&lt;huffman_node *&gt; huffman_tree_node; map&lt;char, int&gt;::iterator it_t; for (it_t = word.begin(); it_t != word.end(); it_t++)&#123; // 为每一个节点申请空间 huffman_node *node = (huffman_node *)malloc(sizeof(huffman_node)); node-&gt;c = it_t-&gt;first; node-&gt;weight = it_t-&gt;second; node-&gt;left = NULL; node-&gt;right = NULL; huffman_tree_node.push_back(node); &#125; // 开始从叶节点开始构建Huffman树 while (huffman_tree_node.size() &gt; 0)&#123; // 按照weight升序排序 sort(huffman_tree_node.begin(), huffman_tree_node.end(), sort_by_weight); // 取出前两个节点 if (huffman_tree_node.size() == 1)&#123;// 只有一个根结点 root = huffman_tree_node[0]; huffman_tree_node.erase(huffman_tree_node.begin()); &#125;else&#123; // 取出前两个 huffman_node *node_1 = huffman_tree_node[0]; huffman_node *node_2 = huffman_tree_node[1]; // 删除 huffman_tree_node.erase(huffman_tree_node.begin()); huffman_tree_node.erase(huffman_tree_node.begin()); // 生成新的节点 huffman_node *node = (huffman_node *)malloc(sizeof(huffman_node)); node-&gt;weight = node_1-&gt;weight + node_2-&gt;weight; (node_1-&gt;weight &lt; node_2-&gt;weight)?(node-&gt;left=node_1,node-&gt;right=node_2):(node-&gt;left=node_2,node-&gt;right=node_1); huffman_tree_node.push_back(node); &#125; &#125; return 0;&#125; Huffman树的特点1）权值越大的结点，距离根结点越近。2）树中没有度为1的结点，这类树又叫做正则（严格）二叉树。3）树的带权路径长度最短 Huffman编码常见的.zip压缩文件和.jpeg图片文件的底层技术都用到了赫夫曼编码。例如字符串S=AAABBACCCDEEA A B C D E 5次 2次 3次 1次 2次 以出现的次数为权值，构建一个赫夫曼树，对每个结点的左右分支进行编号，左0右1，从根到每个结点的路径的数字序列即为每个字符的编码，对A~E的赫夫曼编码规则 A B C D E 0 110 10 1110 1111 则H(S)=00011011001010101110111111110上述有赫夫曼树导出每个字符的编码，进而得到整个字符串的编码的过程称为赫夫曼编码。在前缀码中，任一字符的编码串都不是另一字符编码串的前缀，赫夫曼编码产生的是最短前缀码。 赫夫曼n叉树赫夫曼二叉树是赫夫曼n叉树的一种特例，当对于结点数目大于等于2的待处理序列，都可以构造赫夫曼二叉树，但却不一定能构建赫夫曼n叉树，但无法构建时。需要补上权值为0的结点让整个序列凑成可以构造赫夫曼n叉树的序列。 三、查找(search)查找的基本概念查找的定义：给定一个K值，在含有N个记录的表中找出关键字等于K的记录。若找到，则查找成功，返回该记录的信息或者该记录在表中的位置；否则查找失败，返回相关的指示记录。由于查找算法的基本操作是关键字的比较，并且关键字比较次数与待查找关键字有关（对于一个查找表来说，对其中不同的关键字查找，关键字比较的次数一般不同），因此通常把查找过程中对关键字的平均比较次数作为衡量一个算法优劣的标准，平均查找长度用ASL来表示。 对线性关系结构的查找顺序查找基本思路：从表的一端开始，顺序扫描线性表，一次将扫描到的关键字和给定的K值比较。顺序查找法对于顺序表和链表都是适用的，对于顺序表，可以通过数组下标递增来顺序扫描数组中的各个元素；对于链表，则可以通过表结点指针反复执行p=p-&gt;next来扫描表中的各个元素。 12345678int Search(int a[], int n ,int t)&#123; int i; for (int i = 1; i &lt;=n; ++i) &#123; if(a[i]==k) return i; return 0; &#125;&#125; 时间复杂度为0(n) 二分查找基本思路：① 首先确定整个查找区间的中间位置 mid = （ left + right ）/ 2② 用待查关键字值与中间位置的关键字值进行比较； 若相等，则查找成功 若大于，则在后（右）半个区域继续进行折半查找 若小于，则在前（左）半个区域继续进行折半查找③ 对确定的缩小区域再按折半公式，重复上述步骤。 二分查找必须要求1.存储在数组中2.有序排列时间复杂度$O(logn)$ 分块查找(索引顺序表查找)基本思路：对顺序表进行分块查找需要额外建立一个索引表，表中的每一项对应线性表中的一块，每个索引项都由键值分量和链值分量组成，键值分量存放对应快的最大关键字，链值分量存放指向本地第一个元素和最后一个元素的指针。 二叉排序树与平衡二叉树二叉排序树（BST）二叉排序树（BST）的定义和存储结构二叉排序树或者是空树，或者是满足一下性质的二叉树：1）若他的左子树不为空，则左子树上的关键字的值均小于根关键字的值2）若他的右子树不空，则右子树上所有关键字的值均大于根关键字的值3）左右子树有格式一棵二叉排序树 通常采用二叉链表进行存储，其结点类型定义与一般的二叉树类似 12345typedef struct BTNode&#123; int key; struct BTNode *lchild; struct BTNode *rchild;&#125;BTNode; 二叉排序树的基本算法在二元排序树b中查找x的过程为： 1.若b是空树，则搜索失败，否则： 2.若x等于b的根节点的数据域之值，则查找成功；否则： 3.若x小于b的根节点的数据域之值，则搜索左子树；否则： 4.查找右子树。 在二叉排序树中删去一个结点，分三种情况讨论： 1.若*p结点为叶子结点，即PL(左子树)和PR(右子树)均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。 2.若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉排序树的特性。 3.若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整。比较好的做法是，找到p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除结点s。 二叉排序树的性能介绍每个结点的Ci为该结点的层次数。最好的情况是二叉排序树的形态和折半查找的判定树相同，其平均查找长度和$logn$成正比$O(log2(n))$。最坏情况下，当先后插入的关键字有序时，构成的二叉排序树为一棵斜树，树的深度为n，其平均查找长度为$(n + 1) / 2$。也就是时间复杂度为$O(n)$，等同于顺序查找。因此，如果希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树（平衡二叉树）。 平衡二叉树二叉查找树不是严格的$O(logN)$，当有很多数据灌到我的树中时，我肯定会希望最好是以“完全二叉树”的形式展现，这样我才能做到“查找”是严格的$O(logN)$ 平衡二叉树（AVL）定义父节点的左子树和右子树的高度之差不能大于1，也就是说不能高过1层，否则该树就失衡了，此时就要旋转节点，在编码时，我们可以记录当前节点的高度，比如空节点是-1，叶子节点是0，非叶子节点的height往根节点递增，比如在下图中我们认为树的高度为h=2。 平衡调整AVL树的调整过程很类似于数学归纳法，每次在插入新节点之后都会找到离新插入节点最近的非平衡叶节点，然后对其进行旋转操作以使得树中的每个节点都处于平衡状态。 Left Rotation:左旋,右子树右子节点当新插入的结点为右子树的右子结点时，我们需要进行左旋操作来保证此部分子树继续处于平衡状态。我们应该找到离新插入的结点最近的一个非平衡结点，来以其为轴进行旋转，下面看一个比较复杂的情况： Right Rotation:右旋,左子树左子节点当新插入的结点为左子树的左子结点时，我们需要进行右旋操作来保证此部分子树继续处于平衡状态。 下面看一个比较复杂的情况: Left-Right Rotation:先左旋再右旋,左子树右子节点在某些情况下我们需要进行两次旋转操作，譬如在如下的情况下，某个结点被插入到了左子树的右子结点：我们首先要以A为轴进行左旋操作:然后需要以C为轴进行右旋操作:最终得到的又是一棵平衡树: Right-Left Rotation:先右旋再左旋,右子树左子节点 B-树和B+树的基本概念B-树（B树）的基本概念 B-树中所有结点中孩子结点个数的最大值成为B-树的阶，通常用m表示，从查找效率考虑，一般要求m&gt;=3。一棵m阶B-树或者是一棵空树，或者是满足以下条件的m叉树。 每个结点最多有m个分支（子树）；而最少分支数要看是否为根结点，如果是根结点且不是叶子结点，则至少要有两个分支，非根非叶结点至少有ceil(m/2)个分支，这里ceil代表向上取整。 如果一个结点有n-1个关键字，那么该结点有n个分支。这n-1个关键字按照递增顺序排列。 每个结点的结构为：n k1 k2 … kn p0 p1 p2 … pn其中，n为该结点中关键字的个数；ki为该结点的关键字且满足ki&lt;ki+1；pi为该结点的孩子结点指针且满足pi所指结点上的关键字大于ki且小于ki+1，p0所指结点上的关键字小于k1，pn所指结点上的关键字大于kn。 结点内各关键字互不相等且按从小到大排列。 叶子结点处于同一层；可以用空指针表示，是查找失败到达的位置。注：平衡m叉查找树是指每个关键字的左侧子树与右侧子树的高度差的绝对值不超过1的查找树，其结点结构与上面提到的B-树结点结构相同，由此可见，B-树是平衡m叉查找树，但限制更强，要求所有叶结点都在同一层。 光看上面的解释可能大家对B-树理解的还不是那么透彻，下面我们用一个实例来进行讲解。上面的图片显示了一棵B-树，最底层的叶子结点没有显示。我们对上面提到的5条特点进行逐条解释：1）结点的分支数等于关键字数+1，最大的分支数就是B-树的阶数，因此m阶的B-树中结点最多有m个分支，所以可以看到，上面的一棵树是一个5-阶B-树。2）因为上面是一棵5阶B-树，所以非根非叶结点至少要有ceil(5/2)=3个分支。根结点可以不满足这个条件，图中的根结点有两个分支。3）如果根结点中没有关键字就没有分支，此时B-树是空树，如果根结点有关键字，则其分支数比大于或等于2，因为分支数等于关键字数+1.4）上图中除根结点外，结点中的关键字个数至少为2，因为分支数至少为3，分支数比关键字数多1，还可以看出结点内关键字都是有序的，并且在同一层中，左边结点内所有关键字均小于右边结点内的关键字，例如，第二层上的两个结点，左边结点内的关键字为15，26，他们均小于右边结点内的关键字39和45.B-树一个很重要的特征是，下层结点内的关键字取值总是落在由上层结点关键字所划分的区间内，具体落在哪个区间内可以由指向它的指针看出。例如，第二层最左边的结点内的关键字划分了三个区间，小于15，15到26，大于26，可以看出其下层中最左边结点内的关键字都小于15，中间结点的关键字在15和26之间，右边结点的关键字大于26.5）上图中叶子结点都在第四层上，代表查找不成功的位置。 B-树的查找操作B-树的查找很简单，是二叉排序树的扩展，二叉排序树是二路查找，B-树是多路查找，因为B-树结点内的关键字是有序的，在结点内进行查找时除了顺序查找外，还可以用折半查找来提升效率。B-树的具体查找步骤如下（假设查找的关键字为key）：1）先让key与根结点中的关键字比较，如果key等于k[i]（k[]为结点内的关键字数组），则查找成功2）若key&lt;k[1]，则到p[0]所指示的子树中进行继续查找（p[]为结点内的指针数组），这里要注意B-树中每个结点的内部结构。3）若key&gt;k[n]，则道p[n]所指示的子树中继续查找。4）若k[i]&lt;key&lt;k[i+1]，则沿着指针p[I]所指示的子树继续查找。5）如果最后遇到空指针，则证明查找不成功。 拿上面的二叉树进行举例，比如我们想要查找关键字42，下图加粗的部分显示了查找的路径： B-树的插入与二叉排序树一样，B-树的创建过程也是将关键字逐个插入到树中的过程。在进行插入之前，要确定一下每个结点中关键字个数的范围，如果B-树的阶数为m，则结点中关键字个数的范围为ceil(m/2)-1 ~ m-1个。对于关键字的插入，需要找到插入位置。在B-树的查找过程中，当遇到空指针时，则证明查找不成功，同时也找到了插入位置，即根据空指针可以确定在最底层非叶结点中的插入位置，为了方便，我们称最底层的非叶结点为终端结点，由此可见，B-树结点的插入总是落在终端结点上。在插入过程中有可能破坏B-树的特征，如新关键字的插入使得结点中关键字的个数超过规定个数，这是要进行结点的拆分。接下来，我们以关键字序列{1,2,6,7,11,4,8,13,10,5,17,9,16,20,3,12,14,18,19,15}创建一棵5阶B-树，我们将详细体会B-树的插入过程。（1）确定结点中关键字个数范围由于题目要求建立5阶B-树，因此关键字的个数范围为2～4（2）根结点最多可以容纳4个关键字，依次插入关键字1、2、6、7后的B-树如下图所示：（3）当插入关键字11的时候，发现此时结点中关键字的个数变为5，超出范围，需要拆分，去关键字数组中的中间位置，也就是k[3]=6，作为一个独立的结点，即新的根结点，将关键字6左、右关键字分别做成两个结点，作为新根结点的两个分支，此时树如下图所示： （4）新关键字总是插在叶子结点上，插入关键字4、8、13之后树为： （5）关键字10需要插入在关键字8和11之间，此时又会出现关键字个数超出范围的情况，因此需要拆分。拆分时需要将关键字10纳入根结点中，并将10左右的关键字做成两个新的结点连在根结点上。插入关键字10并经过拆分操作后的B-树如下图： （6）插入关键字5、17、9、16之后的B-树如图所示： （7）关键字20插入在关键字17以后，此时会造成结点关键字个数超出范围，需要拆分，方法同上，树为： （8）按照上述步骤依次插入关键字3、12、14、18、19之后B-树如下图所示： （9）插入最后一个关键字15，15应该插入在14之后，此时会出现关键字个数超出范围的情况，则需要进行拆分，将13并入根结点，13并入根结点之后，又使得根结点的关键字个数超出范围，需要再次进行拆分，将10作为新的根结点，并将10左、右关键字做成两个新结点连接到新根结点的指针上，这种插入一个关键字之后出现多次拆分的情况称为连锁反应，最终形成的B-树如下图所示： B-树的删除对于B-树关键字的删除，需要找到待删除的关键字，在结点中删除关键字的过程也有可能破坏B-树的特性，如旧关键字的删除可能使得结点中关键字的个数少于规定个数，这是可能需要向其兄弟结点借关键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并，其中，和当前结点的孩子进行关键字交换的操作可以保证删除操作总是发生在终端结点上。 我们用刚刚生成的B-树作为例子，一次删除8、16、15、4这4个关键字。（1）删除关键字8、16。关键字8在终端结点上，并且删除后其所在结点中关键字的个数不会少于2，因此可以直接删除。关键字16不在终端结点上，但是可以用17来覆盖16，然后将原来的17删除掉，这就是上面提到的和孩子结点进行关键字交换的操作。这里不能用15和16进行关键字交换，因为这样会导致15所在结点中关键字的个数小于2。因此，删除8和16之后B-树如下图所示： （2）删除关键字15，15虽然也在终端结点上，但是不能直接删除，因为删除后当前结点中关键字的个数小于2。这是需要向其兄弟结点借关键字，显然应该向其右兄弟来借关键字，因为左兄弟的关键字个数已经是下限2.借关键字不能直接将18移到15所在的结点上，因为这样会使得15所在的结点上出现比17大的关键字，所以正确的借法应该是先用17覆盖15，在用18覆盖原来的17，最后删除原来的18，删除关键字15后的B-树如下图所示： （3）删除关键字4，4在终端结点上，但是此时4所在的结点的关键字个数已经到下限，需要借关键字，不过可以看到其左右兄弟结点已经没有多余的关键字可借。所以就需要进行关键字的合并。可以先将关键字4删除，然后将关键字5、6、7、9进行合并作为一个结点链接在关键字3右边的指针上，也可以将关键字1、2、3、5合并作为一个结点链接在关键字6左边的指针上，如下图所示： 显然上述两种情况下都不满足B-树的规定，即出现了非根的双分支结点，需要继续进行合并，合并后的B-树如下图所示： 有时候删除的结点不在终端结点上，我们首先需要将其转化到终端结点上，然后再按上面的各种情况进行删除。在讲述这种情况下的删除方法之前，要引入一个相邻关键字的概念，对于不在终端结点的关键字a，它的相邻关键字为其左子树中值最大的关键字或者其右子树中值最小的关键字。找a的相邻关键字的方法为：沿着a的左指针来到其子树根结点，然后沿着根结点中最右端的关键字的右指针往下走，用同样的方法一直走到叶结点上，叶结点上的最右端的关键字即为a的相邻关键字（这里找的是a左边的相邻关键字，我们可以用同样的思路找到a右边的相邻关键字）。可以看到下图中a的相邻关键字是d和e，要删除关键字a，可以用d来取代a，然后按照上面的情况删除叶子结点上的d即可。 B+树的基本概念可以看到，m阶B+树和B-树的差别主要体现在： 在B+树中，具有n个关键字的结点有n个分支，而在B-树中，具有n个关键字的结点含有n+1个分支。 在B+树中，每个结点（除根结点外）中的关键字个数n的取值为ceil(m/2) &lt;= n &lt;=m,根结点的取值范围为1&lt;=n&lt;=m，他们的取值范围分别是ceil(m/2) -1&lt;= n &lt;=m-1和1&lt;=n&lt;=m-1。 在B+树中叶子结点包含信息，并且包含了全部关键字，叶子结点引出的指针指向记录。 在B+树中的所有非叶子结点仅起到一个索引的作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址，而在B-树中，每个关键字对应一个记录的存储地址。 B+树的优势： 单一节点存储更多的元素，使得查询的IO次数更少。 所有查询都要查找到叶子节点，查询性能稳定。 所有叶子节点形成有序链表，便于范围查询。 散列表（哈希表）哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。根据给定的关键字来计算出关键字在表中的地址 散列表的建立方法以及冲突解决方法设置一个表长为key的hash表，当有多个关键字共用一个地址，这种情况就称之为冲突，这种情况是不允许存在的，因此需要做一些处理来解决冲突，使得每一个地址对应一个关键字。冲突解决办法：在发生冲突的时候，对i属于1~m-1，从冲突地址d开始依次进行$H（key）-（H（key）+i）MOD m$运算，直到没有冲突为止，算出此时的地址为H(key)加入了冲突处理的Hash表在查找时，不能只根据Hash函数来计算地址，还要结合冲突解决方法。 上述Hash表的关键字key查找过程：先用Hash函数来计算地址，然后用KEY和这个地址上的关键字进行比较，如果当前地址上为空，则证明查找失败；如果和当前地址上的关键字相同，则证明查找成功；如果不相同，则根据冲突解决办法到下一个地址继续比较，直到相同为止，证明查找成功。 常用的Hash函数的构建方法1）直接定址法取关键字或关键字的某个线性函数为Hash地址，即H（key）=key 或者H（key）=a*key+b 其中a和b为常数2）数字分析法假设关键字是r进制数（如十进制），并且Hash表中可能出现的关键字都是事先知道的，则可选取关键字的若干数位组成Hash地址，选取的原则是使得到的Hash地址尽量减少冲突，即所选数位上的数字尽可能是随机的。3）平方取中法取关键字平方后的中间几位作为Hash地址。通常在选定Hash函数的时候不一定能知道关键字的全部情况，仅取其中的几位为地址不一定适合，而一个数平方后的中间即为数和数的每一位都相关，由此得到的Hash地址随机性更大，取的位数由表长决定4)除留余数法去关键字被某个不大于hash表长m的数p除后所得到的余数为Hash地址，即$H（key）=keyMOD p$在本方法中，p的选择很重要，一般p选择小于或者等于表长的最大素数，这样可以减少冲突。 处理冲突的方法(1)开放定址法1） 线性探查法$H（key）-（H（key）+i）MOD m$2）平方探查法设发生冲突的地址为d，则用平方探测法所得到的新地址为$d+1^2$，$d-1^2$,$d+2^2$，平方探测法是一种较好的处理冲突的方法，可以减少出现堆积问题，他的缺点不能探查到Hash表上的所有单元，但至少能探查到一半单元。此外，开放定制法的探查方法还有伪随机序列法以及双hash函数法 (2)链地址法链地址法是把所有的同义词用单链表连接起来的方法，在这种方法中，Hash表每个单元中存放的不再是记录本身，而是相同同义词单链表的表头指针。 散列表的性能分析散列表的查找过程基本上和造表过程相同。一些关键字可通过散列函数转换的地址直接找到，另一些关键字在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。查找过程中，关键字的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素： 散列函数是否均匀； 处理冲突的方法； 散列表的装填因子。 散列表的装填因子定义为：α = 填入表中的元素个数 / 散列表的长度α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。通常会将散列表的空间设置的比查找集合大，此时虽然浪费了一定的空间，但会降低产生冲突的可能性，以提升查找效率。 四、排序插入类排序直接插入排序直接插入排序的思想是每一步将一个带排序的记录，插入到前面已经排序好的有序序列中去，直到插完所有元素为止。 123456789101112131415161718192021public static void insertSort(int[] a, int n) &#123; int i, j, k; for (i = 1; i &lt; n; i++) &#123; // 为a[i]在前面的a[0...i-1]有序区间中找一个合适的位置 for (j = i - 1; j &gt;= 0; j--) &#123; if (a[j] &lt; a[i]) &#123; break; &#125; &#125; // 如找到了一个合适的位置 if (j != i - 1) &#123; // 将比a[i]大的数据向后移 int temp = a[i]; for (k = i - 1; k &gt; j; k--) &#123; a[k + 1] = a[k]; &#125; // 将a[i]放到正确位置上 a[k + 1] = temp; &#125; &#125;&#125; 算法性能分析时间复杂度分析 选取最内层循环R[j+1]=R[j];作为基本操作1）考虑最坏情况，整个序列是逆序的，基本操作次数为n(n-1)/2时间复杂度为$O(n^2)$ 空间复杂度分析 算法所需的辅助储存空间不随待排序规模的变化二变化，是个常量，因此空间复杂度为$O(1)$ 折半插入排序折半插入排序思想顺序地把待排序的序列中的各个元素按其关键字的大小，通过折半查找插入到已排序的序列的适当位置。 123456789101112131415161718void BinaryInsertSort(int R[], int n) &#123; int i, j, temp, m, low, high; for (i = 1; i &lt; n; i++) &#123; temp = R[i]; low = 0; high = i - 1; while (low &lt;= high) &#123; m = (low + high) / 2; if (R[m] &gt; temp) high = m - 1; else low = m + 1; &#125; &#125; for (j = i - 1; j &gt;= high + 1; j--) R[j + 1] = R[j]; R[j + 1] = temp;&#125; 算法性能分析折半查找只是减少了比较次数，但是元素的移动次数不变。折半插入排序平均时间复杂度为$O(n^2)$；空间复杂度为O(1)；是稳定的排序算法。 希尔排序希尔排序思想希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。 希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。 12345678910111213141516171819202122232425262728293031/** * 希尔排序 * 参数说明： a待排序的数组; n数组的长度 */public static void shellSort2(int[] a, int n) &#123; // gap为步长，每次减为原来的一半。 for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123; // 共gap个组，对每一组都执行直接插入排序 for (int i = 0; i &lt; gap; i++) groupSort(a, n, i, gap); &#125;&#125; /** * 对希尔排序中的单个组进行排序 * 参数说明： a待排序的数组; n数组总的长度; i组的起始位置; gap组的步长 * 组是"从i开始，将相隔gap长度的数都取出"所组成的！ */public static void groupSort(int[] a, int n, int i, int gap) &#123; for (int j = i + gap; j &lt; n; j += gap) &#123; // 如果a[j] &lt; a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。 if (a[j] &lt; a[j - gap]) &#123; int tmp = a[j]; int k = j - gap; while (k &gt;= 0 &amp;&amp; a[k] &gt; tmp) &#123; a[k + gap] = a[k]; k -= gap; &#125; a[k + gap] = tmp; &#125; &#125;&#125; 算法性能分析希尔排序时间复杂度希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为$O(n²)$，而Hibbard增量的希尔排序的时间复杂度为$O(N^{1.5})$。空间复杂度同直接插入排序一样为O(1)。 希尔排序稳定性希尔排序是不稳定的算法，它满足稳定算法的定义。对于相同的两个数，可能由于分在不同的组中而导致它们的顺序发生变化。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 交换类排序冒泡排序冒泡排序思想冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！当一次交换都没有做，这就说明剩下的序列已经是有序的，排序操作也就可以完成了 12345678910111213141516171819public static void bubbleSort2(int[] a, int n) &#123; int i, j; int flag; // 标记 for (i = n - 1; i &gt; 0; i--) &#123; flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j = 0; j &lt; i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; // 交换a[j]和a[j+1] int tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; flag = 1; // 若发生交换，则设标记为1 &#125; &#125; if (flag == 0) break; // 若没发生交换，则说明数列已有序。 &#125;&#125; 算法性能分析冒泡排序时间空间复杂度冒泡排序的时间复杂度是$O(n^2)$。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度$O(n^2)$。额外的辅助空间只有一个flag，因此空间复杂度为$O(1)$。 冒泡排序稳定性冒泡排序是稳定的算法，它满足稳定算法的定义。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 快速排序快速排序思想快速排序(Quick Sort)使用分治法策略。它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序流程：(1) 从数列中挑出一个基准值(一般选第一个)。(2) 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。(3) 递归地把”基准值前面的子数列”和”基准值后面的子数列”进行排序。 1234567891011121314151617181920212223public static void quickSort(int[] a, int l, int r) &#123; if (l &lt; r) &#123; int i,j,x; i = l; j = r; x = a[i]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt; x) j--; // 从右向左找第一个小于x的数 if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt; x) i++; // 从左向右找第一个大于x的数 if(i &lt; j) a[j--] = a[i]; &#125; a[i] = x; quickSort(a, l, i-1); /* 递归调用 */ quickSort(a, i+1, r); /* 递归调用 */ &#125;&#125; 算法性能分析快速排序稳定性快速排序是不稳定的算法，它不满足稳定算法的定义。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 快速排序时间复杂度快速排序的时间复杂度在最坏情况下是$O(n^2)$，平均的时间复杂度是$O(nlog_2n)$。这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。 空间复杂度为$o(log_2n)$，快速排序是递归进行的，递归需要栈的辅助，因此他需要的辅助空间比前几类排序算法大。 选择类排序简单选择排序从头到尾顺序扫描序列，找出一个最小的一个关键字和第一个关键字交换，接着从剩下的关键字中继续这种选择和交换，最终使序列有序。 12345678910111213141516public static void selectSort(int[] a, int n) &#123; int i; // 有序区的末尾位置 int j; // 无序区的起始位置 int min; // 无序区中最小元素位置 for(i=0; i&lt;n; i++) &#123; min=i; // 找出"a[i+1] ... a[n]"之间的最小元素，并赋值给min。 for(j=i+1; j&lt;n; j++) &#123; if(a[j] &lt; a[min]) min=j; &#125; int tmp = a[i]; a[i] = a[min]; a[min] = tmp; &#125;&#125; 性能分析时间复杂度$O(n^2)$ 空间复杂度$O(1)$ 堆排序最大堆进行升序排序的基本思想：① 初始化堆：将数列a[1…n]构造成最大堆。② 交换数据：将a[1]和a[n]交换，使a[n]是a[1…n]中的最大值；然后将a[1…n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1…n-1]中的最大值；然后将a[1…n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。 堆排序时间复杂度堆排序的时间复杂度是$O(nlog_2 n)$。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是$O(nlog_2 n)$。 空间复杂度 为O(1). 堆排序稳定性堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。 归并排序归并排序思想 从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片) 从上往下的归并排序：它与”从下往上”在排序上是反方向的。它基本包括3步：① 分解 – 将当前区间一分为二，即求分裂点 mid = (low + high)/2;② 求解 – 递归地对两个子区间a[low…mid] 和 a[mid+1…high]进行归并排序。递归的终结条件是子区间长度为1。③ 合并 – 将已排序的两个子区间a[low…mid]和 a[mid+1…high]归并为一个有序的区间a[low…high]。 性能分析归并排序时间复杂度归并排序的时间复杂度是$O(nlog_2 N)$假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是$O(nlog_2 N)$。空间复杂度因归并排序需要转存整个待排序列，因此空间复杂度为O（n）归并排序稳定性归并排序是稳定的算法，它满足稳定算法的定义。 基数排序基数排序思想基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 算法性能时间复杂度 $O(d(n+r_d))$空间复杂度$(r_d)$ 排序算法性能对比 五、图图的基本概念一个图(G)定义为一个偶对(V,E) ，记为G=(V,E) 。其中： V是顶点(Vertex)的非空有限集合，记为V(G)；E是无序集V&amp;V的一个子集，记为E(G) ，其元素是图的弧(Arc)。 1.图图由结点的有穷集合V和边的集合E组成，为了与树形结构进行区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对。若两个顶点之间存在一条边，则表示这两个顶点具有相邻关系。 2.有向图和无向图有向图(Digraph)： 若图G的关系集合E(G)中，顶点偶对&lt;v,w&gt;的v和w之间是有序的，称图G是有向图。 无向图(Undigraph)： 若图G的关系集合E(G)中，顶点偶对&lt;v,w&gt;的v和w之间是无序的，称图G是无向图。 3.弧在有向图中，若 &lt;v,w&gt;(G) ，表示从顶点v到顶点w有一条弧。 其中：v称为弧尾(tail)或始点(initial node)，w称为弧头(head)或终点(terminal node) 。 4.顶点的度，入度和出度无向图中，顶点 v 的度是指和 v 相关联的边的数目有向图中，以顶点 v 为弧头的弧的数目称为顶点 v 的入度，以顶点 v 为弧尾的弧的数目称为顶点 v 的出度 5.有向完全图和无向完全图有向图中每两个顶点之间都有两条方向相反的边连接的图称为有向完全图。弧数为 $n(n -1)$（结点为 n）无向图中每一对不同顶点恰有一条边相连的图称为无向完全图。边数为$n(n−1)/2$（结点数为 n） 6.路径和路径长度从顶点 v 经过一系列的边或弧到达顶点 w ，则称这一系列的边或弧为顶点v 到顶点 w 的路径。路径长度是指路径上边的数目。 7.简单路径序列中顶点不重复出现的路径称为简单路径 8.回路若一条路径中第一个顶点和最后一个顶点相同，则这条路径是一条回路 9.连通,连通图和连通分量在无向图中，如果从顶点 v 到顶点 w 有路径，则称顶点 v 和 顶点 w 是连通的。如果对于图中的任意两个顶点都是连同的，则称为连通图。无向图中的极大连通子图为其连通分量。 10.强连通图和强连通分量在有向图中，如果对每一对顶点 v 、w 从v 和 从w到v都有路径，则称该有向图是强连通图。有向图中的极大强连通子图称为有向图的强连通分量。 11.权和网图中每条边都可以附带一个数，这种与边相关的数称为权，权可以表示从一个顶点到另一个顶点的距离或者花费的代价。边上带权的图称为带权图。 图的储存结构邻接矩阵邻接矩阵是表示顶点之间相邻关系的矩阵，存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 从上面可以看出，无向图的边数组是一个对称矩阵。所谓对称矩阵就是n阶矩阵的元满足aij = aji。即从矩阵的左上角到右下角的主对角线为轴，右上角的元和左下角相对应的元全都是相等的。矩阵中“1”的个数为图中总边数的两倍，矩阵图中第i行和第i列元素之和即为顶点i的度对于有向图，矩阵中“1”的个数即为图的边数，矩阵中第i行的元素之和即为顶点i的出度，第j列的元素之和即为顶点j的入度 有权有向图中，无边的话0变成无限大，1变成权值 邻接表邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构存在对存储空间的极大浪费。因此，找到一种数组与链表相结合的存储方法称为邻接表。邻接表的处理方法是这样的：（1）图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过，数组可以较容易的读取顶点的信息，更加方便。（2）图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以，用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。例如，下图就是一个无向图的邻接表的结构。 图的遍历深度优先搜索遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 123456789101112131415int visit[maxSize];/* V是起点编号，visit[]是一个全局数组，作为顶点的访问标记，初始时所有元素均为0， * 表示所有顶点都未被访问，因为图中存在回路，当前经过的点在将来还有可能再次经过， * 所以要对每个顶点进行标记，以免重复访问，*/void DFS(AGraph *G,int v)&#123; ArcNode *p; visit[v]=1; Visit(v); p = G-&gt;adjlist[v].firstarc;//p指向顶点v的第一条边 while(p!=NULL)&#123; if(visit[p-&gt;adjvex]==0) DFS(G,p-&gt;adjvex); p=p-&gt;nextarc; &#125;&#125; 无向图的深度优先搜索下面以”无向图”为例，来对深度优先搜索进行演示。对上面的图进行深度优先遍历，从顶点A开始。因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索下面以”有向图”为例，来对深度优先搜索进行演示。对上面的图进行深度优先遍历，从顶点A开始。因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 广度优先搜索遍历广度优先搜索算法（BFS）类似于树的层次遍历基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。 1234567891011121314151617181920212223242526void BFS(AGraph *G, int v ,int visit[maxSize])&#123; ArcNode * p; int que[maxSize],front=0,rear=0; itn j; Visit(v); visit[v]=1; rear=(rear+1)%maxSize; que[rear]=v; while(front!=rear) &#123; front=(front+1)%maxSize; j=que[front]; p = G-&gt;adjlist[j].firstarc; while (p!=NULL)&#123; if (visit[p-&gt;adjvex]==0) &#123; Visit(p-&gt;adjvex); visit[p-&gt;adjvex]=1; rear = (rear+1)%maxSize; que[rear] = p-&gt;adjvex; &#125; p = p-&gt;nextarc; &#125; &#125;&#125; 无向图的广度优先搜索因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 最小（代价）生成树最小生成树：在含有n个顶点的连通图中选择n-1条边，构成一颗极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。 普里姆（Prim）算法普里姆(Prim)算法思想是用来求加权连通图的最小生成树的算法。基本思想对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。此时，最小生成树构造完成！它包括的顶点依次是：A B F E D C G。 基本定义代码12345678public class MatrixUDG &#123; private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ...&#125; MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 普里姆算法代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * prim最小生成树 * * 参数说明： * start -- 从图中的第start个元素开始，生成最小树 */public void prim(int start) &#123; int num = mVexs.length; // 顶点个数 int index=0; // prim最小树的索引，即prims数组的索引 char[] prims = new char[num]; // prim最小树的结果数组 int[] weights = new int[num]; // 顶点间边的权值 // prim最小生成树中第一个数是"图中第start个顶点"，因为是从start开始的。 prims[index++] = mVexs[start]; // 初始化"顶点的权值数组"， // 将每个顶点的权值初始化为"第start个顶点"到"该顶点"的权值。 for (int i = 0; i &lt; num; i++ ) weights[i] = mMatrix[start][i]; // 将第start个顶点的权值初始化为0。 // 可以理解为"第start个顶点到它自身的距离为0"。 weights[start] = 0; for (int i = 0; i &lt; num; i++) &#123; // 由于从start开始的，因此不需要再对第start个顶点进行处理。 if(start == i) continue; int j = 0; int k = 0; int min = INF; // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。 while (j &lt; num) &#123; // 若weights[j]=0，意味着"第j个节点已经被排序过"(或者说已经加入了最小生成树中)。 if (weights[j] != 0 &amp;&amp; weights[j] &lt; min) &#123; min = weights[j]; k = j; &#125; j++; &#125; // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。 // 将第k个顶点加入到最小生成树的结果数组中 prims[index++] = mVexs[k]; // 将"第k个顶点的权值"标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。 weights[k] = 0; // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。 for (j = 0 ; j &lt; num; j++) &#123; // 当第j个节点没有被处理，并且需要更新时才被更新。 if (weights[j] != 0 &amp;&amp; mMatrix[k][j] &lt; weights[j]) weights[j] = mMatrix[k][j]; &#125; &#125; // 计算最小生成树的权值 int sum = 0; for (int i = 1; i &lt; index; i++) &#123; int min = INF; // 获取prims[i]在mMatrix中的位置 int n = getPosition(prims[i]); // 在vexs[0...i]中，找出到j的权值最小的顶点。 for (int j = 0; j &lt; i; j++) &#123; int m = getPosition(prims[j]); if (mMatrix[m][n]&lt;min) min = mMatrix[m][n]; &#125; sum += min; &#125; // 打印最小生成树 System.out.printf("PRIM(%c)=%d: ", mVexs[start], sum); for (int i = 0; i &lt; index; i++) System.out.printf("%c ", prims[i]); System.out.printf("\n");&#125; 普里姆算法时间复杂度分析观察代码发现，普里姆算法主要部分是一个双重循环，外层循环内有两个并列的单层循环，单层循环内的操作都是常量级别的，其执行次数为n的平方，因此普里姆算法的时间复杂度为O(n$^2$) 克鲁斯卡尔（Kruskal）算法克鲁斯卡尔算法思想克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。 根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：问题一 对图的所有边按照权值大小进行排序。问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”(关于这一点，后面会通过图片给出说明)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 以下图来进行说明：(01) C的终点是F。(02) D的终点是F。(03) E的终点是F。(04) F的终点是F。关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。 基本定义代码123456789101112// 边的结构体private static class EData &#123; char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重 public EData(char start, char end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125;&#125;; EData是邻接矩阵边对应的结构体。123456789public class MatrixUDG &#123; private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ...&#125; MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 克鲁斯卡尔算法代码123456789101112131415161718192021222324252627282930313233343536/* * 克鲁斯卡尔（Kruskal)最小生成树 */public void kruskal() &#123; int index = 0; // rets数组的索引 int[] vends = new int[mEdgNum]; // 用于保存"已有最小生成树"中每个顶点在该最小树中的终点。 EData[] rets = new EData[mEdgNum]; // 结果数组，保存kruskal最小生成树的边 EData[] edges; // 图对应的所有边 // 获取"图中所有的边" edges = getEdges(); // 将边按照"权"的大小进行排序(从小到大) sortEdges(edges, mEdgNum); for (int i=0; i&lt;mEdgNum; i++) &#123; int p1 = getPosition(edges[i].start); // 获取第i条边的"起点"的序号 int p2 = getPosition(edges[i].end); // 获取第i条边的"终点"的序号 int m = getEnd(vends, p1); // 获取p1在"已有的最小生成树"中的终点 int n = getEnd(vends, p2); // 获取p2在"已有的最小生成树"中的终点 // 如果m!=n，意味着"边i"与"已经添加到最小生成树中的顶点"没有形成环路 if (m != n) &#123; vends[m] = n; // 设置m在"已有的最小生成树"中的终点为n rets[index++] = edges[i]; // 保存结果 &#125; &#125; // 统计并打印"kruskal最小生成树"的信息 int length = 0; for (int i = 0; i &lt; index; i++) length += rets[i].weight; System.out.printf("Kruskal=%d: ", length); for (int i = 0; i &lt; index; i++) System.out.printf("(%c,%c) ", rets[i].start, rets[i].end); System.out.printf("\n");&#125; 克鲁斯卡尔算法时间复杂度分析算法时间花费主要在函数sort()和单层循环上。循环是线性级的，可以认为算法时间主要花费在sort()上，因为排序算法时间复杂度一般大于常量级，因此，克鲁斯卡尔算法的时间复杂度主要由选取的排序算法决定，排序算法所处理的数据的规模由图的边e决定，与顶点无关，因此克鲁斯卡尔算法适用于稀疏图。 最短路径迪杰斯特拉算法（Dijkstra）迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 迪杰特斯拉算法基本思想通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 操作步骤(1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。(2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。(3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。(4) 重复步骤(2)和(3)，直到遍历完所有顶点。单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 基本定义代码12345678910111213141516// 邻接矩阵typedef struct _graph&#123; char vexs[MAX]; // 顶点集合 int vexnum; // 顶点数 int edgnum; // 边数 int matrix[MAX][MAX]; // 邻接矩阵&#125;Graph, *PGraph;// 边的结构体typedef struct _EdgeData&#123; char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重&#125;EData; Graph是邻接矩阵对应的结构体。vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。EData是邻接矩阵边对应的结构体。 迪杰斯特拉算法代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * Dijkstra最短路径。 * 即，统计图(G)中"顶点vs"到其它各个顶点的最短路径。 * * 参数说明： * G -- 图 * vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。 * prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。 * dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。 */void dijkstra(Graph G, int vs, int prev[], int dist[])&#123; int i,j,k; int min; int tmp; int flag[MAX]; // flag[i]=1表示"顶点vs"到"顶点i"的最短路径已成功获取。 // 初始化 for (i = 0; i &lt; G.vexnum; i++) &#123; flag[i] = 0; // 顶点i的最短路径还没获取到。 prev[i] = 0; // 顶点i的前驱顶点为0。 dist[i] = G.matrix[vs][i];// 顶点i的最短路径为"顶点vs"到"顶点i"的权。 &#125; // 对"顶点vs"自身进行初始化 flag[vs] = 1; dist[vs] = 0; // 遍历G.vexnum-1次；每次找出一个顶点的最短路径。 for (i = 1; i &lt; G.vexnum; i++) &#123; // 寻找当前最小的路径； // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。 min = INF; for (j = 0; j &lt; G.vexnum; j++) &#123; if (flag[j]==0 &amp;&amp; dist[j]&lt;min) &#123; min = dist[j]; k = j; &#125; &#125; // 标记"顶点k"为已经获取到最短路径 flag[k] = 1; // 修正当前最短路径和前驱顶点 // 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。 for (j = 0; j &lt; G.vexnum; j++) &#123; tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); // 防止溢出 if (flag[j] == 0 &amp;&amp; (tmp &lt; dist[j]) ) &#123; dist[j] = tmp; prev[j] = k; &#125; &#125; &#125; // 打印dijkstra最短路径的结果 printf("dijkstra(%c): \n", G.vexs[vs]); for (i = 0; i &lt; G.vexnum; i++) printf(" shortest(%c, %c)=%d\n", G.vexs[vs], G.vexs[i], dist[i]);&#125; 迪杰斯特拉算法时间复杂度分析由算法代码可知，本算法主要部分为一个双重循环，外层循环内部有两个并列的单层循环，可以任取一个循环内的操作为基本操作，基本操作执行的总次数为$n^2$ 因此时间复杂度为$O(n^2)$. 弗洛伊德（Floyd）算法弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。 弗洛伊德算法思想通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素b[i][j]，表示顶点i到顶点j经过了b[i][j]记录的值所表示的顶点。 假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞，矩阵P的值为顶点b[i][j]的j的值。 接下来开始，对矩阵D进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”,更新b[i][j]=b[i][0]。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k-1]+a[k-1][j]”，则更新a[i][j]为”a[i][k-1]+a[k-1][j]”,b[i][j]=b[i][k-1]。更新N次之后，操作完成！ 弗洛伊德算法过程1）设置两个矩阵A 和PATH，初始时将图的邻接矩阵赋值给A，将矩阵Path中元素全部设置为01.2）以顶点K为中间顶点，k取0~n-1(n为图中顶点个数)，对图中所有顶点对{i，j}进行如下检测：如果A[i][j]&gt;A[i][k]+A[k][j]，则将A[i][j]改成A[i][k]+A[k][j]的值，将Path[i][j]改成K，否则什么也不做 弗洛伊德算法代码12345678910111213141516171819void Floyd(MGraph g,int Paht[][maxSize])&#123; int i,j,k; int A[maxSize][maxSize]; //这个双循环对数组A和Path进行了初始化 for(i=0;i&lt;g.n;++i)&#123; A[i][j]=g.edges[i][j]; Path[i][j]=-1; &#125; for (int k = 0; k &lt; g.n; ++k) &#123; for (int i = 0; i &lt; g.n; ++i) &#123; for (int j = 0; j &lt; g.n; ++j) &#123; if(A[i][j]&gt;A[i][k]+A[k][j])&#123; A[j][j] = A[i][k]+A[k][j]; Paht[i][j]=k; &#125; &#125; &#125; &#125;&#125; 弗洛伊德算法时间复杂度分析由算法可知，主要是有三层循环，基本操作执行次数为$n^3$，所以时间复杂度为$O(n^3)$ ​ 拓扑排序AOV网活动在顶点上的网（Activity On Vertex network,AOV）是一种可以形象的反映出整个工程中各个活动之间的先后关系的有向图。 拓扑排序介绍拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。 拓扑排序算法思路 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)； 把所有没有依赖顶点的节点放入Q； 当Q还有顶点的时候，执行下面步骤：3.1 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)；3.2 对n每一个邻接点m(n是起点，m是终点)；3.2.1 去掉边&lt;n,m&gt;;3.2.2 如果m没有依赖顶点，则把m放入Q;注：顶点A没有依赖顶点，是指不存在以A为终点的边。以上图为例，来对拓扑排序进行演示 第1步：将B和C加入到排序结果中。​ 顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边&lt;B,A&gt;和&lt;B,D&gt;，并将A和D加入到队列Q中。同样的，去掉边&lt;C,F&gt;和&lt;C,G&gt;，并将F和G加入到Q中。​ (01) 将B加入到排序结果中，然后去掉边&lt;B,A&gt;和&lt;B,D&gt;；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。​ (02) 将C加入到排序结果中，然后去掉边&lt;C,F&gt;和&lt;C,G&gt;；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。第2步：将A,D依次加入到排序结果中。​ 第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。第3步：将E,F,G依次加入到排序结果中。 因此访问顺序是：B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>961</tag>
      </tags>
  </entry>
</search>
